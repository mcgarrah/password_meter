(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// Copyright 2017 by Carnegie Mellon University
// globals on entry:
// $ for JQuery (infected with Bootstrap)
// LZString for LZString
// log for LogLevel
// optional passwordMeterConfig for configuration
exports.__esModule = true;
//potentialTODO bootstrap has infected jquery already
//import Bootstrap = require("bootstrap");
var Helper = require("./helper");
var Config = require("./config");
var PasswordMeter;
(function (PasswordMeter) {
    var Registry = (function () {
        function Registry() {
            this.data = {};
            /* bootstrap apparently infects jquery
                setBootstrap(bootstrap:Bootstrap):void {
                    this.data["bootstrap"] = bootstrap;
                }
            
                getBootstrap():Bootstrap {
                    return this.data["bootstrap"];
                }
                */
        }
        Registry.prototype.setConfig = function (config) {
            this.data["config"] = config;
        };
        Registry.prototype.getConfig = function () {
            return this.data["config"];
        };
        Registry.prototype.setJquery = function (jquery) {
            this.data["jquery"] = jquery;
        };
        Registry.prototype.getJquery = function () {
            return this.data["jquery"];
        };
        Registry.prototype.setLzstring = function (lzstring) {
            this.data["lzstring"] = lzstring;
        };
        Registry.prototype.getLzstring = function () {
            return this.data["lzstring"];
        };
        Registry.prototype.setLog = function (log) {
            this.data["log"] = log;
        };
        Registry.prototype.getLog = function () {
            return this.data["log"];
        };
        Registry.prototype.setHelper = function (helper) {
            this.data["helper"] = helper;
        };
        Registry.prototype.getHelper = function () {
            return this.data["helper"];
        };
        Registry.prototype.setDictionaries = function (dictionaries) {
            this.data["dictionaries"] = dictionaries;
        };
        Registry.prototype.getDictionaries = function () {
            return this.data["dictionaries"];
        };
        Registry.prototype.setUI = function (ui) {
            this.data["ui"] = ui;
        };
        Registry.prototype.getUI = function () {
            return this.data["ui"];
        };
        Registry.prototype.setNN = function (nn) {
            this.data["nn"] = nn;
        };
        Registry.prototype.getNN = function () {
            return this.data["nn"];
        };
        return Registry;
    }());
    PasswordMeter.instance = new Registry();
    PasswordMeter.instance.setJquery($);
    PasswordMeter.instance.setLzstring(LZString);
    PasswordMeter.instance.setLog(log);
    var helper = new Helper.Helper.Helper($, LZString, log);
    PasswordMeter.instance.setHelper(helper);
    var config = (typeof passwordMeterConfig === "undefined") ?
        Config.Config.passwordMeterDefaultConfig :
        passwordMeterConfig;
    PasswordMeter.instance.setConfig(config);
    if (typeof window !== "undefined") {
        window.PasswordMeter = PasswordMeter.instance;
    }
})(PasswordMeter = exports.PasswordMeter || (exports.PasswordMeter = {}));

},{"./config":3,"./helper":6}],2:[function(require,module,exports){
/* ***************** */
/* ARRAY EXTENSIONS */
/* ***************** */
// pretty print array to string (foo, bar and baz)
Array.prototype.toHumanString = function () {
    // potentialTODO expect contiguous array.
    var length = this.length;
    if (length == 0)
        return "(empty)";
    if (length == 1)
        return this[0].toString();
    var buildString = this[0].toString();
    for (var i = 1; i < length - 1; i++) {
        buildString += ", " + this[i].toString();
    }
    buildString += " and " + this[length - 1].toString();
    return buildString;
};
// Remove duplicate elements in array
Array.prototype.removeDuplicates = function () {
    var uniques = this.filter(function (item, i, ar) {
        return ar.indexOf(item) == i;
    });
    return uniques;
};
// Checks for membership of x in the array
// Accepts an optional parameter strict where true indicates
// a case-sensitive check. By default, we assume strict is false.
Array.prototype.contains = function (x, strict) {
    var i = this.length;
    strict = typeof strict !== 'undefined' ? strict : false;
    while (i--) {
        if (this[i] == x) {
            return true;
        }
        // Check non-case-sensitive equality
        if (!strict && typeof x == 'string' && typeof this[i] == 'string') {
            if (x.toLowerCase() == this[i].toLowerCase()) {
                return true;
            }
        }
    }
    return false;
};
// potentialTODO should this be only in array?
// Returns an array of all substrings of each array element.
// Substrings are ordered from longest (max_length) to shortest (min_length).
Array.prototype.listSubstringsMinMax = function (minLength, maxLength) {
    var a = new Array();
    var longestPartLength = 0;
    for (var part = 0; part < this.length; part++) {
        longestPartLength = Math.max(longestPartLength, this[part].length);
    }
    // potentialTODO handle this better?
    // Set the default minLength to 2 if unspecified
    minLength = typeof minLength !== 'undefined' ? minLength : 2;
    // Set the default maxLength to the length of the longest part if unspecified
    maxLength = typeof maxLength !== 'undefined' ? maxLength : longestPartLength;
    // Iterate (descending) through substring lengths
    for (var i = maxLength; i >= (minLength); i--) {
        // Iterate through password parts
        for (var k = 0; k < this.length; k++) {
            // If password part is at least the length we're examining
            if (this[k].length >= i) {
                for (var j = 0; (j + i) <= this[k].length; j++) {
                    a.push(this[k].substring(j, j + i));
                }
            }
        }
    }
    return a;
};

},{}],3:[function(require,module,exports){
"use strict";
// test 8 dimensions of composition requirements as follows:
//   dimension 1: length (min / max)
//   dimension 2: mandatory # of character classes
//   dimension 3: mandatory character classes
//   dimension 4: forbidden character classes
//   dimension 5: forbidden passwords
//   dimension 6: permitted/forbidden characters
//   dimension 7: repeated consecutive characters
//   dimension 8: password - username comparison
exports.__esModule = true;
var Config;
(function (Config) {
    Config.passwordMeterDefaultConfig = {
        colors: {
            compliant: "#006600",
            noncompliant: "#660000"
        },
        symbols: {
            compliant: "&#x2714; ",
            noncompliant: "&#x2751; "
        },
        remindAgainstReuse: true,
        ignoredWords: // list of words that should count for nothing in the password 
        ["pittsburgh",
            "steelers", "stillers", "penguins", "pens", "pirates", "bucs", "carnegie", "mellon",
            "university"],
        forbiddenPasswords: // list of passwords that should be rejected
        ["123456", "password", "12345", "12345678", "qwerty", "1234567890", "1234",
            "baseball", "dragon", "football", "1234567", "monkey", "letmein", "abc123",
            "111111", "mustang", "access", "shadow", "master", "michael", "superman",
            "696969", "123123", "batman", "trustno1"],
        length: {
            active: true,
            minLength: 8,
            maxLength: 0
        },
        classCount: {
            active: false,
            minCount: 1,
            maxCount: 4
        },
        classRequire: {
            active: false,
            upperCase: false,
            lowerCase: true,
            digits: true,
            symbols: false
        },
        classAllow: {
            active: false,
            upperCase: true,
            lowerCase: true,
            digits: true,
            symbols: true
        },
        forbidPasswords: {
            active: true,
            includeLargerList: true
        },
        forbidChars: {
            active: false,
            list: []
        },
        repeatChars: {
            active: true,
            limit: 3
        },
        usernameDifference: {
            active: true,
            limit: 1
        },
        neuralNetworkConfig: {
            intermediate: "basic_3M.info_and_guess_numbers.no_bloomfilter.json",
            file: "basic_3M.weight_arch.quantized.fixed_point1000.zigzag.nospace.json",
            zigzag: true,
            scaleFactor: 300
        }
    };
})(Config = exports.Config || (exports.Config = {}));

},{}],4:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Constants;
(function (Constants) {
    Constants.LOWERCASE_LETTERS = new RegExp("[a-z]");
    Constants.LOWERCASE_LETTERS_GLOBAL = new RegExp("[a-z]", "g");
    Constants.UPPERCASE_LETTERS = new RegExp("[A-Z]");
    Constants.UPPERCASE_LETTERS_GLOBAL = new RegExp("[A-Z]", "g");
    Constants.NONALPHA = new RegExp("[^A-Za-z]");
    Constants.DIGITS = new RegExp("[0-9]");
    Constants.DIGITS_GLOBAL = new RegExp("[0-9]", "g");
    Constants.SYMBOLS = new RegExp("[^A-Za-z0-9]");
    Constants.SYMBOLS_GLOBAL = new RegExp("[^A-Za-z0-9]", "g");
    Constants.startASCII = 32;
    Constants.endASCII = 126;
    Constants.commonStructures = ["LLLLLL", "LLLLLLLL", "LLLLLLL", "DDDDDDDD", "DDDDDD", "LLLLL", "DDDDDDD", "LLLLLLDD", "LLLLLLLLL", "LLLL", "DDDD", "LLLLLLLD", "LLLLLD", "LLLLLLLLLL", "LLLLLDD", "LLLLDDDD", "LLLLLLD", "LLLLDD", "LLLLLDDD", "DDDDD", "LLLDDD", "LLLDDDD", "DDDDDDDDD", "LLLLLLLLLLL", "DDDDDDL", "LLLLLDDDD", "LLLLDDD", "LLLLLLLDD", "DDDDDDDDDD", "LLLLLLLLLLLL", "LLLLLLDDDD", "DDDDDDDDL", "UUUUUUUU", "LLLLLLDDD", "LLDDDD", "DDDDDDDDDDD", "ULLLLL", "LLLLLLLLDD", "LLLLLLLLD", "ULLLLLLL", "UUUUUU", "ULLLLLLD", "LLLLLLLLLLLLL", "ULLLLLL", "LLLLLLLDDDD", "LLLLLLLDDD", "ULLLLLD", "DDDDLLLL", "LLLLLLLLLLLLLL", "LLLLD", "LLDDDDDD", "DLLLLLLL", "UUUUUUU", "LLLLLLLLLD", "DDLLLLLL", "DDDDLL", "DDDDDDLL", "LDDDDDD", "LLLDDDDD", "ULLLLLDD", "LLLLLLLLDDDD", "DDDLLL", "LLLLLLLLLDD", "DDDDDDDL", "LLLLLLLLLLLLLLL", "DDDDLLL", "DULLLLL", "DULLLLLL", "LLLDDDDDD", "ULLLLD", "LLLLLLLLDDD", "DLLLLL", "DDDDDDLLL", "LLLLDLLL", "LLLLDDDDDD", "ULLLL", "LLLDD", "LDDDDDDD", "LLLDLLLL", "LLLLLLLLLLLLLLLL", "DDLLLL", "LLLDDLLL", "DDDDDDDDDDDD", "DLLLLLL", "DDLLLLL", "LLLLLDLL", "LLLLLLLLLLDD", "LLDDDDD", "LLLLLDDDDDD", "DDDLLLLL", "LDDDDDDDD", "DDDDDDLLLL", "UUUUU", "LLLLLLDL", "LDDDDD", "ULLLDDDD", "ULLLLDDD", "ULLLLLLLL", "LLLLLLLLLDDD", "DDDDDL", "LLLLLLDDDDDD", "LLLLLLLLLLDDDD", "DULLLL", "ULLLLDD", "LLLLDDDDD", "LLLLDL", "LDLLLLLL", "LLDLLLLL", "LLLDLL", "LLDLLL", "LLLLLLLLLLD", "LLLDLLL", "LLLLLDDDDD", "DDDDLLLLL", "LDLDLDLD", "DDDDDDDDLL", "DDDDDDDDLLL", "LLLLLLLLLDDDD", "DDDLLLL", "DDDDDDDDLLLL", "DLLLLLLD", "LLDDD", "LDLDLD", "LLLD", "DDDDDDDDDL", "DLLLDLLL", "LDLLLL", "LLLLDDDDDDDD", "LLLLDLL", "UUUU", "ULLLLDDDD", "LLLLLDL", "ULLLLLLDD", "DDLLLLDD", "LLLLLLDDDDD", "LLDDLL", "DDDDLLLLLL", "DDDDDLLL", "DDDDDDDDDDDL", "DDDDDDDDDDL", "LLLDDDDDDDD", "LDDDDL", "LLLLDDLL", "ULLL", "LLLLLLLLLLLDD", "LLLLLLLLLLLLLLLLL", "DDDDDDLLLLL", "LLLLLLLLLLLLDD", "LLLLLLLLLLLD", "ULLLLLDDDD", "LDDDLL", "ULLLLLLLLL", "ULLLDD", "LLLDDDDDDD", "LLDDDDDDD", "LLLDLLLD", "DDLLLDD", "DDDDDDDLL", "LLDDDDDDDD", "ULLLLLLLD", "LLLLLDDL", "DLDLDLDL", "LLDDDDLL", "DDDDDDDLLL", "DLDLDL", "ULLLLLDDD", "LLLLLDDDDDDDD", "UUUUUUDD", "LLDLLLL", "LLLLLLLLLLDDD", "LDDDDDDL", "DDDDDLL", "ULLLD", "LLLLDDDDDDD", "LLDDLLLL", "LLLDDDLL", "DDDDDDLLLLLL", "DLLLLD", "DLLLL", "LLLLLLLLLLLLLLLLLL", "LLLDDLL", "ULLLLLLLDD", "LLDDLLDD", "UUUUUUUUU", "LLLLLLLLLLLDDDD", "DULLL", "ULLLDDD", "DDLLLLLLL", "LLL", "UUUUDDDD", "DDLLDD", "DDDLLLLLL", "DDDDDDDDLLLLL", "LLLDDL", "DLLLLLD", "DDDDDDDLLLL", "LDLLLLL", "UUUDDDD", "LLLLLLLDDDDDD", "DLLLLLLLL", "LLLLLLLLLLLDDD", "LLLLLLLLLLLLLDD", "LLLLLLDDDDDDDD", "UUUUUD", "UUUUDD", "LDDLLLLL", "LLLLDLLLL", "DDDDLLLLLLL", "LLLLLDDDDDDD", "DDDDL", "UUUDDD", "LLLLLLLLLLLLD", "UUDDDD", "UUUUUUUD", "LLLLLLLLLLLLDDDD", "LDLDLDLDLD", "LDDD", "LLDLLD", "DDDDDDU", "LLLLDDL", "LLLDDDDL", "UUUUUDD", "LLLLLLLDDDDD", "DDLLLLLDD", "UDDDDDD", "LLDD", "LDDDD", "LLDDDLL", "ULLLULLL", "DDDDLLLLLLLL", "LDLLLDLL", "DDDDDLLLL", "LDDLLL", "LLLLLDLD", "ULLLLLLDDD", "ULLLLU", "DDLLL", "LLDDLLL", "ULLLLLLDDDD", "LDDLDD", "LDLLDL", "ULLLLLLLLLL", "LLDLLLDL", "", "LLLLDLLD", "LLDLLDLL", "LLLDL", "LLDLLLLD", "ULDDDDDD", "ULLULL", "LLLDDDLLL", "UUUUUDDD", "LLDLL", "UUUUUUD", "LLLLDDDL", "LLLLLLLLLLLLLD", "LLLLLLLLDDDDDD", "UUUUUUUUUU", "LDLLLLDL", "LLLLDLDL", "LDLLDLLL", "LLLLLLLLLLLLLLLLLLL", "DLDLLLLL", "DDDLLLDDD", "DDDDDLLLLL", "LLLDDDL", "DLLLLDLL", "LLLDLLDL", "LLLLLLLLLLLLDDD", "LDDDDDDDDD", "ULLLLLLLLD", "LDLDLLLL", "LLLLLLLLLLLLLLDD", "DDLLLLLLLL", "LLDLDLLL", "DLLLLLDL", "DDDDDDDDU", "DDDDDDDDLLLLLL", "LDDDDDDDDDD", "LDLLLLLD", "DDLLLLLLDD", "LLDDDL", "LLLDLDLL", "DLLL", "ULLDDDD", "DDLLDLLL", "DLLLLLLLLL", "DLLDLLLL", "DDDLL", "LLLLLLDDDDDDD", "DDD", "LLLLLLLDDDDDDDD", "LLLDLD", "DDLLLLLD", "DLLDLL", "LLLLLLDLL", "UUDDDDDD", "DDDDDDDDDLLL", "LLDDDLLL", "ULLLLLLLLDD", "ULULLL", "DDLLDDLL", "DLLLLLDD", "LDLLL", "DDDDDDDLLLLL", "DDLDDLDDL", "ULULUL", "ULLLUL", "LDLLLD", "UDDDDDDDD", "LLLLLDLLL", "LDLDLL", "ULLLLULL", "DDDDDDDDDDDDD", "ULLLLLLLDDDD", "UUUUDDD", "LLLLLLLLLLLLLLLLLLLL", "DDDDDDDDDDDDDD", "DDDLDDD", "DDLDDL", "DLLLDL", "ULLLUU", "DLDLDLDLDL", "ULLLLLLLDDD", "ULLDDD", "LLLLLLDLLL", "DDDLLLLLLL", "DDDDDDDDDDLL", "DDLLLDDDD", "UDDDDDDD", "ULUULL", "ULULLU", "ULLLLLLLLLD", "ULUULU", "DDDDDDDDDLL", "LLLLLDLLLL", "DDDDDDDDDDDLLLL", "ULUUUL", "ULUUUU", "ULLUUU", "ULLULU", "ULLUUL", "LLDLDL", "LLLLLLLDL", "LLLLLLLS", "LLDL", "LLLLLLLLLLLLLLD", "LDDDDDDDDL", "LDDDLLL", "LLLLLLS", "ULULUU", "LDDDDDDDDDDD", "LLLLLLLLLLLLLDDD", "LLLLLLLLLDDDDDD", "DDDDDDLLLLLLL", "DDDDDDDDDDLLL", "LLLDDLLD", "DDDLLDDD", "LDDLDDLDD", "LLLDLLLLL", "ULLLLLLLLLLL", "LLLLDDLLL", "DDLLLD", "LLLDDDDLLL", "DDDDDDDDDDDLLL", "LDLDLDL", "LLLLLLLLDDDDD", "LLLLSLLL", "LLLLLLLLDDDDDDDD", "DLLLDD", "LLLLDLD", "DDDDDDDDDDDDDDDD", "DLDLLL", "UUUUUDDDD", "DDDDDDDDDDLLLL", "LLLLDLLLLL", "DLLLD", "DDDDDDDU", "DDDDDDUU", "DDDLLLDD", "LLDDDDL", "DLLLLLLLD", "LLLSLLL", "LDDLLLL", "ULLLDDDDDD", "LLLLLLLLLLLLLDDDD", "DDLLLLD", "ULLULLLL", "LLLDDLLLL", "LLLLDDLLLL", "DDDLLLLDDD", "LDLL", "LDDDDDDDL", "LLLDLLLLLL", "DDDDDDDDDLLLL", "LDDDLLDD", "LDDDLLLL", "LLDDLLLD", "DDDDDDDDDDDLL", "LLLDLLDD", "DDLL", "DDDDUU", "DDLDDLDD", "DDDDDDLLLLLLLL", "DDLDDDD", "DDDDLLDD", "LLLLLS", "ULLDDDDDD", "LLDLLDL", "LDLDLDLL", "LLLLDLDD", "LDLLLLLLL", "DDDLLLD", "LLDLLLDD", "ULLDDDDD", "ULLLLLLU", "ULDDDD", "LLLDDLLLDD", "UUUUUUUDD", "LLLLLLLDDDDDDD", "UUUDDDDD", "LLDLLLD", "UUDDDDD", "LDLDL", "UUUUUUUUUUU", "LDLLLLDD", "LLDLLLLLL", "LLLDDLDL", "DLLLDLL", "DLLLLDD", "LLLLLSDD", "DDDDULLL", "DDLLDDDD", "LLLLLLLDLL", "DLLLLDL", "LLLLLLLLDL", "LDLLLDL", "DLDLDLD", "LLDLDD", "LLLDDDDDDDDD", "ULLLLDDDDDD", "LDDDLDDD", "DDDDDDDDDDDDDDD", "DDDDDDDDDDDDL", "ULLULLL", "LDLDLDLDLDLD", "LLLDLLD", "DDDDDDDLLLLLL", "LDDDDDL", "DDDLLLLLLLLL", "LLDDL", "LLLLLLDDL", "LDLLDLL", "LDLLDLDL", "LLLLLLLLLLLLLLLDD", "UULLLLLL", "ULLLLLLLLLDD", "LDDDDLL", "LDLLDLLD", "DDDLDD", "DDLLLLLLLDD", "LLLLLLLLS", "UUUUUUDDDD", "LLLLDDLD", "UDDDDD", "LLDDLDLL", "DDDDDDDDLLLLLLL", "UUUDDDDDD", "DDDDLDDDD", "LLDDLD", "LLLLLDDLLL", "DDLLLDDD", "UUUUUUDDD", "LLLLLDDLL", "LLLLDDDDDDDDDD", "DDDLLLLLLLL", "LLLLLLLLLDDDDD", "LDLLDD", "LLLLLLLLLLLLLLLLLLLLL", "LLLLLLLLLLLLLLLD", "LLLSLLLL", "DDDDLD", "DDLDDD", "DDDDUUUU", "DLDLL", "LDLLLLD", "DLDLLLDL", "LLLLSLLLL", "LDLDLLDL", "DDLDLLLL", "DDDDDDDDDDDLLLLL", "LLLLLLLLLLDDDDDD", "UUUUUUUUUUUU", "LLLDLDL", "LLLLDDDDDDDDD", "DDDDDLLLLLL", "DDULLLLL", "ULLLULL", "LLLLLLLLLLLLLLDDDD", "DLLDLLDL", "LLLDLDLD", "LLLDDDDDDDDDD", "DDDDLLLLDDDD", "LLLLSL", "LDLDLLL", "DLLLLLLLLD", "LDLLLDLD", "DDDDLDD", "ULDDDLL", "LLDLLLLLLL", "LLLLLLSDD", "DLDLLLL", "ULLLLLLLLDDD", "LLDLDLL", "DDDDDDS", "DDLLLLLLLLL", "LDLLLDDL", "ULLLLDLL", "DDLLLDLL", "DDLLDL", "LLLLLSLLL", "DLLLDDLL", "LDLDLDLDL", "DLLLDLDL", "DLLDLLL", "DLLDL", "DLDLDLLL", "LLDDLLD", "DDDLLLLLDDD", "DDSDDSDDDD", "LLDDLLDL", "DLLDLLLD", "DLLLDDD", "LLDLLDDL", "LLLLLU", "DLLDLDLL", "LDDLDL", "LDDLLD", "LLDLLDLD", "DDLLDDD", "DDDDLLLD", "DLLDDL", "ULLLLLDDDDDD", "DDDLDDDL", "DDLLD", "LLLLLDLLLLL", "LLLDDLDD", "LLDLDLLD", "LDDDDLLL", "DLLDDLLL", "LLLLDDDDDDDDDDD", "DLDLLDLL", "LLDDDDDDDDD", "DDDDDDUUU", "DLDDLLLL", "DDDLLD", "LDDLLLLD", "LDLLLLLLLL", "DDDDUUU", "LLDLDLDL", "DLLLLDLD", "DDLLLLDDDD", "ULLLLDDDDD", "LUULDDL", "ULLLDDDDD", "LDDLLLDL", "ULLLLLLLLDDDD", "DDLLLLDL", "DLLLLLLLLLL", "ULLLLLU", "LLLLLSLL", "DLLLLDDL", "LDLDLLLD", "DLDLLLLD", "UUUDD", "LDLDDLLL", "LLLLLLDLLLL", "LDLLD", "DDDDDDUL", "LDLD", "DLLLLDDD", "LDLLDDLL", "UUUUD", "LDDLLDLL", "LLLLLLLLDDDDDDD", "LLLDLDDL", "DLLLDLLD", "DDDDDDDDDDLLLLL", "LLLLLDDDDDDDDD", "DDDDDDDDUU", "LLLLLDDDDDDDDDD", "ULDDDDDDDD", "UUULLL", "LLLLLSLLLLL", "LLLLLSLLLL", "DLDLLD", "LLLSDDDD", "LLDDDDDDLL", "DLLLDDDD", "DLDLD", "ULLLLLLLLLLLL", "LLLLLLULLLLL", "LLDLDDLL", "LLLLLLLLLLLLLLDDD", "DDDDLLD", "LLLDDDLD", "ULLLLULLLL", "LDDLL", "DDLLLDDL", "DDDLLLLD", "DDDL", "ULDDDDDDD", "LLLLLLLU", "DDDLLDD", "LLLLLLLLLLDDDDD", "DDLDD", "LLLLLLLLLLLLLLLLLLLLLL", "UDLLLLLL", "LLLLSDD", "LDDLDLLL", "DLDDLL", "LLLLSLLLLL", "LLLLSLLLLLL", "LLDDDDDDDDDD", "DLDDDD", "ULLLDLLL", "LLLDDDDLL", "DDDDLDDD", "DLDLDLDLDLDL", "ULLLLLUL", "DDLDLL", "UUULLLLL", "UDDDDDDL", "LLLLLLDDDDDDDDD", "LLLLLLLLLS", "LLSLLL", "LLDLD", "DDDLDDDD", "LLLLLLLLLLLLLLLLDD", "LLLDDLD", "LLLLLLSD", "UUUUUUUUDD", "LDLDDD", "LLDLLDD", "DDDDLLLDDDD", "DDLLLLLLLLDD", "LLLLDDDDLLLL", "DDDDDU", "UUUDDDUU", "DDDDDDDDLLLLLLLL", "LLLLDLLLLD", "UUUUUUUUD", "LLLLSDDD", "LLLLLDDDDDDDDDDD", "DDDLLLLLLDDD", "DLLDDD", "DLLDLD", "LLDDLLLLL", "UDDDDDDU", "LSLLLL", "LLLLLLULLLLLL", "DDDDDDDDDLLLLL", "LLLLLLDDLL", "DDDDDDDDS", "LLLLLSDDD", "LDDLLDDL", "ULLULLDD", "DLLLLLLDD", "ULLLLULLL", "LLDLLDDD", "UULLLL", "ULLLULLLL", "LLLLLLSLLL", "LLLDDLLLLL", "UUDDDDDDDD", "LLLLLLU", "DDDDDDLLLLLLLLL", "ULLLDDDDDDDD", "DDLDL", "DLLDD", "LDLDDL", "LDDLDDL", "LLLLLLDDDDDDDDDD", "LLLLLLSLLLLLL", "DDDLD", "DDDDDDLD", "DDLLLLLDDDD", "LDDLDDDD", "UUDDDDDDD", "DUUUUUUU", "LDDL", "DDDUUU", "ULULLLLL", "LDLDLDD", "LLLDDDDDDDDDDD", "DLLDDLLD", "UUUUUUUDDD", "LLLDLDD", "DDDDLLLDD", "LLLLLDDDL", "ULLLLLDL", "ULULULUL", "LLLLLLLDDL", "LDDLLLDD", "ULLLLLLLLLLD", "DDDULLLL", "LLLSLL", "LLLLLLSL", "LLLDDDLLLDDD", "LLLDDDLLLL", "LLLLDDDLLL", "LDLLLDDD", "LLLSLLLLL", "LLLLDDDDL", "LLLLDDDLL", "LDDDL", "LLLLLLULLLLLLL", "DDDDDDDDDDLLLLLL", "LLLLLLLSDD", "UDDDDU", "LLLDLDDD", "LLLLLSLLLLLL", "LLDDLDD", "DLDDL", "LDLLLDD", "LLLLLLDDLLL", "DDLDLLL", "DDDDDDDDDDDU", "LLDDLDL", "DLLDLLD", "LDDDDLDDDD", "LLLLLLSLLLLL", "DDDDDDDDDLLLLLL", "UUUUUUUDDDD", "ULDDDDD", "LLLDLLLDDD", "DDLLDDL", "ULLLLLDDDDD", "LLDDDLLD", "UUUULLLL", "ULLLLLUU", "DDDDDDDLLLLLLL", "LLLLDDDLLLL", "DLDDLD", "DDDDLLDDDD", "DDSDDSDD", "ULLDLLLL", "LDDLDDLD", "DDDDDDDDUUU", "DLLDDLL", "DDDDDDDDDDDDDDDDDD", "LLLLLLLLLLLLLLLDDD", "ULLLU", "LLLLLLDLD", "UUDDDDUU", "LLLLLDDDDL", "LLLLLLLLLLLLLLLDDDD", "LLLSDD", "LLLLLLSLLLL", "LLLLLLLLLDDDDDDD", "LSLLLLL", "LDDDLD", "ULLLLDDDDDDDD", "DDDDLLLLLDDDD", "DDDDDDDDDU", "LLLLSDDDD", "LDDLDDLL", "ULLLLUDD", "LDLLDDDD", "ULLULLLD", "LLLDDDDDDLLL", "LLDDDDDL", "ULLDDLLL", "DDDLDL", "LLLLLSL", "LDLLDLD", "LDLLDLDD", "LDLDLLD", "DLDLDD", "DDDDLLLLLLLLL", "LLLLDDDDLL", "LLLDLLLLD", "DDLLDLL", "DDLLLLLLDDDD", "ULLDD", "UUUDDDDDDDD", "ULULLLL", "DDLDDLLL", "LDLDLLDD", "ULLLULLD", "DLLDLLDLL", "DDUUUUUU", "LDDLLDD", "ULULDDDD", "LLLLLLLLDLL", "LLLLSLL", "LLLLDLLLLLL", "DDLLLLLLLLLL", "LLDLLDLLD", "LLLLLSDDDD", "LLLLLLLLLDL", "DLDLDLDLD", "LLLLLSD", "LLLLLDDLLLL", "DDDDDDDDDDDDLLL", "DLDL", "LLLLDDLLLLL", "LLLLLLLDLLL", "LLSLLLLL", "DDLLLLLLD", "DDLDDDDD", "LDDLLLLLL", "LLDDDDLLL", "DLDDDL", "LLLLLDDLLLLL", "LLLLLLLLLLLLLLLLLDD", "LLLLLLLLLLLDDDDD", "LLLLLLLSLLLLLL", "LDDLLDL", "LLLLLLUU", "DULLLLLD", "UUUUDDDDDD", "DLLD", "UUDDD", "LLLLLLLDLLLL", "LLLLLLLLLDDDDDDDD", "LDLLDDL", "DDULLLL", "ULLLDL", "DLLLDLLLDLLL", "LLLLDDDDLLL", "LDLDLDDD", "LLDLDDDD", "DLDDD", "DDDDDDDDDDU", "LLUULL", "LLLLLLSDDD", "UULLDDDD", "LLLLUU", "LDLDDLDL", "DDDLLLDL", "LLLLLLLLSDD", "DDDLDLLL", "UULLLLL", "ULLLLLLLLLLDDDD", "DDDDDDDDUL", "ULLLDDDLLLL", "LLLSDDD", "DDLDDLL", "DDDSDDD", "LLLULL", "DDDDUL", "DDDDDLLLLLLL", "UUUUDUUU", "DLDLDLL", "LDLDDLDD", "LLLLLLLLLLLDDDDDD", "DDDDULLLL", "ULDLLLLL", "DDLDLD", "DDDDDDLLLLLLLLLL", "DDDDDLDD", "DDDLLLLLDD", "LDLDLDDL", "ULDLDD", "LLLLLLDDDL", "DLLLLDLLL", "LLLUUU", "LLLLLDDDLL", "DDLLDLLD", "DLLLDDDL", "DDDDDDDDDDDDLLLL", "DLLLDDL", "LLDDLDDL", "ULLLULLLLL", "DLDLLLD", "ULLDLL", "DLDLLLDD", "LSLLLLLL", "DLLDDDLL", "DLLLLDLLLL", "DDDLLDLL", "ULLDDDDDDD", "LLLLLLLSD", "LLLLUL", "DLLDLLDD", "LLLSLLLLLL", "UDLLLL", "LLLLLLSLLLLLLL", "UUULLLDD", "DDLDDLD", "LLLLLLLLLLLLLLLLD", "DDDDDDDS", "LULLLL", "LLLLLLSDDDD", "DDUUUUU", "UDDDDDDDDD", "LLSLLLL", "DDDDLLLLDD", "LLLLLLLSLLLLL", "DDDLLLLDD", "LDDLLLD", "LLLLDLLLD", "LLLLULLL", "DDULLL", "DDSULL", "LDDDLLLD", "LDDDDLDD", "DDDDDDDDDDDDLL", "LLLLLLLULLLLL", "ULLLLLLLLLDDDD", "UUUUUDUU", "DDDDDLD", "ULLDDDDDDDD", "LLLLLLLDDDDDDDDD", "ULLLLULLLLL", "DDLLLDL", "LLLLLSLLLLLLL", "UUUDUUUU", "DDUUUU", "DLLLLLLLLLLL", "LDDLD", "LLLLLLULLLL", "LLDLDLDD", "UULLLLDD", "ULUL", "ULLLLUUU", "ULLLDDDDDDD", "LDDDLDLL", "DLDDLDLL", "LDLDDDDD", "LLDDDDDDL", "ULLLLLUD", "DDDDLLLLLLDDDD", "UULLLDDD", "ULLLLLDDDDDDDD", "DLLLDLLLL", "LDDLLDLD", "DLLLLLLDL", "LLDDLLLLLL", "DLDDDLLL", "LLLLLULL", "DDDDDDDUU", "DDDLLLDDDLLL", "UUDDDUU", "LDDLDLDL", "LDDDDDLL", "DDDDDDDDDDDDDDDDDDDD", "UULLUU", "LLDDDLDD", "UUU", "LULULU", "UUUDLLLL", "UDDDUU", "DLLLDDLD", "DDLLDLDL", "DDDUUUUU", "LDLLDDDL", "DLDDDDDD", "SLLLLL", "LLLDLLLLLLL", "UDDDDDDDDL", "LDLLDDLD", "UULLL", "LLDDDLDL", "LLLLLDLLD", "ULLLDLL", "DDLDDLDDDDL", "LLLLU", "UUUUUUDU", "ULLLLLULLLL", "DDLDDDDL", "ULLLLLULLLLL", "DLLDDLDL", "DLLLLLLLLLD", "LLLLLLLSLLLL", "UDDDDDDDDDD", "ULLLLLULLL", "LDDLLDDD", "DLLLDLD", "DDDDDUU", "DDLDDLDDDD", "UUUUUUUUUD", "DLDLLDL", "LLDDDDDDDDLL", "LLDLLLLDL", "LLLLLLLLLLLLLLLLLLLLLLL", "DLLDDLD", "DLDDLLL", "DLDLDDLL", "DDDDULL", "LDDDLLDDD", "LLDDLDLD", "LLLLLLLLLLLLLLLLDDDD", "DDLLLLDDD", "LDLDDDLL", "LLLDDDDLLLL", "DLLDLDL", "DLDLDLLD", "LDLLLLDLL", "LLULLLLL", "UUUUULLL", "UUUUUUUUDDDD", "ULLLLDDDDDDD", "LDDDDDDDDDL", "UDUDUD", "DUUUUU", "LLLLSLLLLLLL", "UDDDD", "DLDDLLDL", "DDLDLDLL", "ULLULULL", "DDDLDDL", "DLLDLDLD", "LLDLDDL", "LLULLL", "UDLDLDLD", "UUULLLL", "LLLLLLLULLLLLL", "DLDDLLLD", "ULLLLDL", "LLDDDDDDDDDDD", "LLDLDDLD", "LLLLLLSLL", "DDLDLLDL", "DDLLLDLD", "DDL", "LLDLDLD", "LDDDDDDDDDDL", "LDDLDLLD", "DLLDDDD", "DDLDLLLD", "ULLDLLL", "DLLLDLDD", "LDLDD", "UDDDDDDDL", "LLLLLLDDLLLL", "DDDDDUUU", "LDDLLLLLLL", "UDUDUDUD", "DDDLDLL", "DLDLLDDL", "LLLLLLSLLLLLLLL", "DLLDLDDL", "ULLULLD", "LLLLDLLDD", "LDDLDLDD", "ULLLLLLLLLLDD", "ULLLLLLDDDDDD", "ULLLLLLLLLLLLL", "ULLSDD", "LDDDLDD", "UDLLLLL", "DLDDDDD", "LLLLLLLLLLDDDDDDDD", "LUUUUU", "DDU", "LULULL", "LLLLLLLLLLLLLLLLLLLLLLLL", "LLLLLLLSLLLLLLL", "LDLDDLLD", "LLLLLLLSLL", "DLDLLDLD", "DLDLLLLLL", "UUUUUUUUUDD", "LDDDLLDL", "UUUUUUUUUUUUU", "DDUUU", "LDLLLLLLD", "LDLDDDD", "DDDDLLDL", "DSDSDDD", "DLDDLLD", "LLLDDDLLLD", "LDDLDDD", "LLLLLLLDLD", "LLULUL", "LLDDLDDD", "ULLLLLULL", "LLLLDDLLLLDD", "LDLDDLL", "LLLDDLLDD", "DLDLDLDD", "LLLLLLLLLSDD", "LLDDDDDLL", "DDDDDLLD", "LLLLLDLDL", "LLLLLLDLLLLL", "UUDUUUUU", "LLLLLLLLSLLLLLL", "LLLLLLUUUUUU", "SSSSSS", "LLLLLLLLLLLLDDDDDD", "DDULL", "LLLLLLLLLLSLLLLL", "DDDDDS", "LLDLDDD", "DLLLLLDLL", "ULLLLUD", "DUUUU", "LLLLLLLLSL", "DLDDLDDL", "LLLLLLLLLLLSLLLL", "LLLLLDDDLLL", "ULDLLL", "ULLLLLLULLLL", "UUUDDDDDDD", "ULLLULLU", "UULLLU", "ULLLULUL", "LDDLDLL", "DUUUUUU", "DDDDLDDDDL", "LLLLLLLLSLLLLL", "DDDLLDL", "LLLLLLLLLDLL", "ULLLLLLDDDDD", "LLLLLLLSLLL", "LLLLLLLLLSLLL", "UDUUUUUU", "LDLDLLLLL", "DDDDDDUUUU", "DULLLULL", "DDDDDDULLL", "LLDLLLLLLLL", "ULLULLUL", "LLDDLLLDD", "LLLLUD", "UUUD", "ULLDDULL", "ULLLLLLLLLDDD", "LLLLLLDDDDL", "DDDDDDDLLLLLLLL", "UULLLLLD", "LDLLDLLLL", "LLLULLLL", "LLDLLLLDLL", "DDLDDLDDLDDL", "LLLLLSLLLLLLLL", "LDLLDDD", "ULULU", "LULLUL", "LLLULU", "LLLLLLLLLLLSLLLLL", "DDDDDDLU", "UULUUL", "LLDDLLDDLLDD", "LLLLLLLSL", "DDLDDLDL", "LLLLLLUD", "UUUUUULL", "UDDDUDDD", "LLLDDDLLLLLL", "ULLLUD", "ULLLDDLL", "LDDDDDDDDDDDD", "UDDDDDDDDDDD", "ULULL", "ULLLLDDL", "DDLLDDDL", "DDDDLDDL", "SLLLLLL", "LLLLLLLDDLL", "DDDDLLLLLDD", "ULULULU", "SLLLLLLL", "LLLLDLLDL", "UUDDUU", "DDLLLLLLLLLDD", "UUUULU", "UUUDDUUU", "UUULUU", "LLUULU", "DLLDLLLLL", "LLUUUU", "ULLULULU", "ULUUUULL", "DDLDDDLL", "LLDLLLLLD", "ULLLDULL", "DDDDLLLLLLLLLL", "ULLULLLU", "LLLLLLLLLLSLLLL", "DULLLLLLL", "ULLUDDDD", "LLLLLDDDDLLLLL", "LLLLDDDDDDDDDDDD", "DDDDU", "DDDULL", "DDULLLDD", "LLLLLLLLSLLLL", "LLDLDDDL", "LLLDLDLLL", "LLLLLLLSDDDD", "LLDDDLD", "UUUUDDDDD", "DSDSDSDDD", "DDDDULLLLL", "DDLDDLLD", "LLLLLLLULLLLLLL", "ULLULLLLL", "ULULLLUL", "LDLLLLLLLLL", "UUUULL", "LLLDLLDLL", "LDLLLLLDL", "ULULULLL", "DDDLLLLLLLDDD", "DDUUUDD", "LLLLLLLLULLLLL", "LDDLDDLDDLDD", "ULLUULLU", "DLLLLLLU", "ULULLLLU", "LDDLDLD", "LLLUDD", "UULULL", "LLLLLLLLLLLLLLLLDDD", "UUUUUDDDDDD", "LLDLLLDLL", "DDDLDDLL", "DDDUUUU", "LDDDLLD", "LLLLLLULLLLLLLL", "DDDDDDULL", "LLLLLLLLSLLL", "UUUUUUUUDDD", "LDLDDLD", "ULLLUULL", "ULULLULL", "LLLLLLLLDLLL", "LLLLLLLLLLSLLL", "LLLLLLLDDLLL", "DDDDDDDDDDS", "LLLLLLLLLLLLDDDDD", "UDDDDDDDDU", "LLLLLLLLLLDL", "ULLLLULU", "LLUUUL", "DUUUUUUD", "LUULUU", "LLLLLLLLLLLSLLL", "ULULUUUL", "LLLLLLLLLLLLSLLL", "LDDDDDDLL", "UUULLLDDD", "ULLLULLLLLL", "DDLLDDLD", "ULULLULU", "LLLLLLLSDDD", "LLLLLLLLLSLLLL", "DDLLDLD", "ULLUL", "LLLLLLLLLLLLLLLLLLDD", "LLLLLLLLLSLLLLLL", "DUDLUDUL", "DLLLLDDDD", "DDLDLLDD", "UUULUL", "LLLLLLLLDDL", "LLLLLLLLLSLLLLL", "ULLUUUUU", "SSSSS", "UULLLULL", "DLDLLDDD", "ULLULLUU", "ULULUULU", "LULUUU", "LLLLLLLLSLLLLLLL", "LLLLLLLSLLLLLLLL", "LLLLLUUU", "LLLDDLLLLLL", "ULLLLUL", "DDUUUUDD", "DDLDDDL", "LDDLDDLDDDD", "LLLLUUUU", "UULLLLLU", "LLLULLL", "ULULLLUU", "ULLUULLL", "DDDDDDDDDDDDDDL", "LUULLU", "LLLDLLLLLD", "LLDDLLDDLL", "LDDLDDLDDL", "LLDDDLLLL", "LLLDLLLDL", "LUUULL", "LUULLL", "DLLDLDD", "UULLUUUL", "ULULLUUL", "LDLDLDLDLDL", "DDLDLDDL", "ULUUULLL", "UULLULLL", "ULLLUUUU", "DDUU", "LLLDDDLLLLL", "LLLLLLUUUUUUU", "UUUDUUU", "LLULUU", "LLLLLLLLLLLSDD", "ULLLLUUL", "ULUULULU", "LLLUUL", "LLLLLDLLLLLL", "LULLLLLL", "UUDUUU", "DDDDLDLL", "LLSLLLLLL", "LLLLDDDLLLLDDD", "UUUULULL", "UUULLUUL", "LLLLLLLLLLLLSLLLLL", "LULLL", "DDDLLLDDDD", "DDDDDDDDUUUU", "LLLLDLDLL", "LSLLL", "DLDLDDDL", "LDDDLLLLL", "LDDDDDDDDDDDL", "UULLLLUL", "UULUUU", "UUULLLLU", "UULULU", "ULUULULL", "UUUUULUU", "UUUDU", "ULUULUUL", "UUULLULL", "ULLUUULU", "ULULULLU", "UULLLLUU", "UUDUU", "DULULLLL", "UULLLUUU", "DDDDLDL", "ULLLULUU", "UUULLLLD", "LLLLLLLDLLLLLL", "LLLLLLLLDLLLLLL", "DDDLDLLD", "DDLLLLLLLD", "LLLLLLLLSLLLLLLLL", "LLDLLDLLL", "UUULULLL", "LLLLLLDDDLLL", "LLLDLLLDD", "UUULUULL", "ULLUULUL", "UULUUULL", "UULLULLU", "LSLLLLLLL", "LLLLSLLLLLLLL", "DLLLLLDLLL", "LDDDLLDDLLL", "LLLSLLLLLLL", "LDLLLDLLL", "DLLLDLLLLL", "LLLLSD", "LLLLLDDDDLL", "LLDDDLLDDD", "LLLLLLDLDL", "ULDDLLLL", "LLLLDDLLLLLL", "LLDLLLLLDL", "UDDUDD", "DDLLDLDD", "LLLLLLDDS", "UUUDDLLL", "ULUULUUU", "DLLDDDDD", "DDUUDD", "UULLULUU", "DDLUL", "DDDDDDDDDDDLLLLLL", "LUUULU", "DULLU", "DULUL", "LLLLLLLLDLLLL", "LLLDDLLLD", "DDDDDDDDULLL", "DDDULLL", "DDDDDDUD", "UULULLLL", "ULLLLLLLU", "ULLULUUL", "ULLUUULL", "LLLUUD", "LLLLLLDLLD", "LLLLLLDDDLL", "UUUUUUUUUUUUUU", "LDDDLDDL", "UDDLLLLL", "UULLLUUL", "DDDLLDDDD", "DDUUL", "ULULDD", "UULULULU", "UDUUU", "DDLLLLLLLDDDD", "ULUUUUUL", "DLDDLLDD", "LSLLDDDD", "DDDDDDDDDDDDDDDDD", "LLULL", "DULLULLL", "LULLLU", "LLLLLLLLLLLSLLLLLL", "LLLLLLLULLLL", "UUUUUL", "ULDDLL", "DLLLLLLLDD", "UULLUULU", "UDDDUUDD", "LLLLLLLLULLLLLL", "DLDDLDL", "UUUUUUDDDDDD", "DDLLU", "DDDLLLLLLLLLL", "ULLLLSDD", "LLLLLLLLU", "LLLLLLLLLLLLLLLLLD", "DDDDDDDDDDDS", "UUULLULU", "LLLLDLLLLLLL", "DDDLLDDL", "DDDDDDULLLL", "LLDLLLDLLL", "DLDLDDD", "LLLLLLLLSD", "UUUUUUUL", "DDDDDLDL", "LLLUL", "UUUUUULU", "DULLLLUL", "LLLLLUDD", "LSLLLLLLLL", "DLDLLDD", "ULLLLLDDDDDDD", "UUULULUL", "LLUUL", "UULULLUL", "LLUUUD", "UUUULUUL", "ULLDULLL", "ULDDDDDDDDD", "DDLLDDLLDD", "ULLUULUU", "ULUULLUL", "ULUUULLU", "UUULUUUU", "UUUUDU", "DDDDLLLLD", "UULUUUUU", "ULULULUU", "DLDLDDL", "LLLLLLULLLLDD", "ULULULDD", "DDDLLLLLLLLDDD", "DDUULLLL", "ULLLULLLDD", "LLLLLDLLLLLD", "ULLLUUUL", "DDLDLDD", "ULUULLUU", "DLLUL", "UUULLLUU", "DDDDSDD", "DDLLDDDDDD", "DDDDDDLLLLDD", "LLLLLLLLLLSLLLLLL", "UUULLLUL", "DDDDDDDUL", "UUULULUU", "LLLLLDDDDLLL", "DLLUU", "DLLLLLLLLLLD", "ULLLLLSD", "LLLLLLLLLLLLSLLLL", "UDDDDUDD", "LLLLLLLLULLLLLLL", "DDLDLLD", "DDDDLLLDDD", "UUUDUU", "ULULUULL", "DDDUU", "LLLLLLLDLLLLLLL", "LUULUL", "UULLUUUU", "DDDDDDLLLLLDD", "DLLULLLL", "DDLDLDLD", "DDDLDDLD", "ULLLULDD", "ULDLLLL", "DDDDUDDD", "LDDLDDDL", "DDLDLDL", "ULLLLLSDD", "UDDDDDU", "ULULLUUU", "LDLDLDLDLDLDLD", "LLLLLLLLLLLLSDD", "DLLLDLLLD", "DLDDDLDD", "ULUUUULU", "UUUUDDDDDDDD", "UUUUUDDDDD", "DUUULLLL", "ULLULUUU", "LDLLLLDLLL", "LLLLLLLLLLLDDDDDDDD", "ULLLLULLLLLL", "LLULU", "DLUULLUL", "LLLLLLULLLLLDD", "UUUUULUL", "ULLLUDDD", "LLLLDLDLLL", "DDUDDUDD", "DULLLULU", "DLLLLLDDDD", "LLLLLDDDDLLLL", "UUULL", "DLLDDLDD", "UUULUULU", "DDDDDDDDDDDDDL", "ULLLUULU", "UULUULLU", "DUULLUUL", "ULLLLLLLDDDDDD", "ULUULLLU", "DLLULULL", "LUULL", "DLDDDLLD", "LLLLLLLLLLSDD", "DDLU", "DULULUUL", "DLDDLDD", "UULLULUL", "DDLDDDLD", "LLLLDDDDUU", "DLULU", "ULUUUUUU", "LLLLLLLLDDLL", "LLLLDLLLDL", "DDUL", "ULULUUUU", "ULUULLLL", "UDDUDDUDD", "LLDDDDLD", "LLULLU", "UDUUUU", "UUUULLUU", "LLLLLLDDDDLLLLLL", "DDDLDLDL", "ULUUULUL", "UUULULLU", "UUDDUUDD", "ULLLLLDDS", "DLLDDDL", "DDDDDDLLLLLLDD", "UULUULLL", "UULULULL", "DLLLULLU", "ULULLLLD", "DULLLLLU", "LLDLDLLLL", "DLDDDDL", "ULULUD", "UUUULLLU", "UUUULLUL", "UUULLUUU", "DUUULLUL", "DUUULULU", "UULLUULL", "DDDDDDLDD", "DDDDUUUUU", "DDDLLLLLD", "LLLLLLUL", "DLLLLLLLDL", "LLDLLLLDD", "DULULLLU", "DDDDLLDDD", "UULUUUUL", "DULULULU", "DDDDLLLLLLLDDDD", "LLDLLLLLLD", "LLLLLDLDD", "UULULLLU", "LLLDDDDLLLLLL", "LLLLLLDDDDDDDDDDD", "DLDLDDDD", "LLLLLLLLLLLLLLLLLDDDD", "DDDDLDLD", "LLDDDDLLLL", "LLLLLLLDDDL", "DDLD", "LLLUU", "DDDLDLD", "DDULU", "DUULLLUL", "UUUUULLU", "DLLDLDDD", "DDLDLDDD", "ULLUUUUL", "DLLUUULU", "ULLU", "DUULLLLL", "UULUULUL", "UULULLUU", "LLLLDU", "DLLUULUU", "DDDDDDDDDLLLLLLL", "DLLLLLUU", "ULUUULUU", "DDDDDDDUUU", "ULDDD", "LLUUU", "DLDLDLDLDLD", "DDLLLDDLL", "LLDDDDDDDLL", "DDDLLDLD", "ULLDULLD", "DLLLULLL", "UULLLULU", "DULULULL", "UULUULUU", "DDLLLLLDDD", "DULULLUL", "UDDUDDDD", "UUUULULU", "DDDDLLLLLLDD", "DUULU", "DLLLLULU", "DDULLLLLL", "DLLLULUU", "DDDUDDDD", "LLLLLDLLDL", "UUDDDDLL", "DLDLLLLLLL", "DDLLLDDLLL", "LLLLLSLLLLLLLLL", "LLLLLLLLLLLLSLLLLLL", "ULLLUDD", "LLLDULLL", "DUUUL", "DDDDDDSS", "UULULUUL", "LLLDDDDDDDDLLL", "DUULLLLU", "LLDLLDLLLL", "DUULLULU", "LLLLLUU", "DDLDDDDDD", "DUUULLUU", "DDLUU", "LLLLDLLDLL", "DLDDDLL", "UUUULUUU", "LLDLDLLLLL", "DLLLU", "LLLLLLLDLLLLLLLL", "LLLLLDLLLD", "LLULLD", "LDLLLLDDL", "DDDLDLDD", "UUULLU", "DDDDDDDDDS", "DUULULUU", "UDDUDDD", "ULLLUUU", "DLULUUUL", "UDDDDL", "DUUUULLU", "LLLLLLLLLDDL", "LLLLLLLLLLSLLLLLLL", "LLLUUUDD", "LDLLLDLLLL", "DLDDDLD", "LDDDDLD", "DULUUULL", "DLLUUULL", "DULUULLU", "UULUUULU", "LLLLLDDS", "ULLLLLDDDLLLL", "ULLDL", "UULLLD", "LLLDDDDLLLLL", "DULLLUUL", "LLLDLLDLLL", "DUULULLL", "UULLUL", "DDDDLLLLLLLLLLL", "ULLLLLLDDDDDDDD", "ULLLLUU", "DLUUULUL", "DULUULLL", "DDDDDDDLDD", "DLLULLLU", "ULLLLULD", "ULLDLLLD", "DULLULUL", "DLLDDDDL", "LUUUUL", "DUULD", "DLUUUULL", "DUUULLLU", "LLLLLLLLLLLLLSLLLLL", "LUUUU", "UULLLDD", "DDULLLLDD", "DLLULL", "UULLDD", "DSULL", "DLLLUULL", "UULULUUU", "ULUUL", "DUUUULUU", "DLULLULL", "UDLLLLLD", "DDLDLLLLL", "UULUL", "ULLLLLLULLL", "LLLLLLDS", "UDDDDDDDU", "LLLLLLLLLDLLL", "DLLUULLL", "LLLDDDDDDDDDDDD", "DLLLLLDDD", "DDDDDDDDDDDDDDDL", "ULUDDD", "DULLUULL", "LLLLLUD", "ULLLLLLLLLLLLLL", "LDDDLDLD", "UUUUDUU", "UDDDDDUD", "DLULLLLU", "LLLDLLDDD", "LLLLLLLLLLLLLLLLLDDD", "ULDDDDLL", "DULLUULU", "DUUUULUL", "LDLLLLLLLD", "LLDLLDDDD", "DDLLDDLLDDLL", "DLULULLL", "DULUULUL", "DULLLU", "DLLLULUL", "DUULLLUU", "LULLUU", "DUULLULL", "DLDDDDLL", "LLSLLLLLLL", "DDDDDDULLLLL", "ULLULLLLLL", "DULUU", "DULLULLU", "LDDDDLLD", "ULULLLDD", "DLLLLLUL", "DUDUDUDU", "LLLLLLDLLLLLL", "ULDDULDD", "DULLUUUL", "LLLLLDDDLLLL", "ULDULL", "LLLLLDDDLLLLL", "DLLLUUUU", "LUDDDDDD", "ULDULD", "UDLLLLDD", "ULLLDLLLL", "DUUULUUU", "ULLD", "UUUDUUUD", "ULLLLLLS", "DUULULUL", "DUULUUUL", "UDDUDDUD", "DLDDDLDL", "UUUUUUUUUDDD", "LLDDDDDDLLL", "DLDDLDDD", "LLLLLLLLLLS", "DDULLDD", "DULULLUU", "DUULULLU", "UUDDUUUU", "LLLLLLLLLLLDL", "DDDDDDLLLLLLLLLLL", "ULLLLUUD", "DLDLLLLLD", "UUUDDDU", "DULUULUU", "LLLLLLLLLLLLLDDDDDD", "ULLLULLLD", "DLLUULLU", "LULUUL", "DUUULUUL", "UUUDDUU", "LLLDLLLDLL", "DUUUUUUL", "DUULL", "LDDLLLDDL", "DDLLLLLLLLLLL", "UUUUDDUU", "DDDDDDDDLLLLLLLLL", "ULLUU", "LLLLULLD", "UUUDDDDU", "LLLLLLLLLSLL", "DDSDDSDDDDS", "DLLUUUUL", "UULUU", "DLUUULLL", "LLLLLLLLDLLLLLLL", "DULULUUU", "DLLDDDLD", "DLUUULUU", "DDDDDDLLD", "DULULU", "ULL", "ULUUU", "ULLDDLL", "DULUUULU", "DUUUUULU", "UUUUUDDU", "LLLLULL", "LLLLDDDDDDLLLL", "UUDD", "DUULUULL", "UUUUL", "DLLLDDLLL", "LLLLLLLLLLLLLDDDDD", "ULULLLD", "ULLLLLDLL", "DDDDDUDD", "LLLLLLDDDDLLL", "DLULLLLL", "DLUULULL", "ULLLLLLLLLLLDD", "DULLLUUU", "LLLDLDLLLL", "LLLLLDLLDD", "ULLLLLLDS", "DULLLLD", "LUUUUUUU", "ULLLLLLLLLLDDD", "ULLUDD", "ULLLLLLLLLLLD", "LLLLUULL", "DLULUULU", "DDDDSDDDD", "DDDUUDDD", "LLLLLLLLLLLLLSLLLL", "DLLLLUUU", "DLLULLUU", "DUUUULLL", "DUULUULU", "LLDDDLLLLL", "LLLDDDLLLLLLLL", "DDDDDDLLLDD", "DUUULULL", "DLDULU", "DLUUULLU", "DULLUUUU", "DUUDU", "LLLLLLLLLLLLSLLLLLLL", "LULULULU", "LLLLLDDLD", "DLUULLLL", "DDDDUUDD", "LLLLLLLLLLSLL", "LULLU", "DLLULLUL", "DULUUUUL", "DDSDDSDDS", "ULLLLLULLLLLDDDD", "ULULUDDD", "ULLLLLUDD", "LDLDDDL", "DUULUUUU", "LLLDDDDDDDLLL", "LLLLLLLLLLLLDDDDDDDD", "DLDDLDLD", "LLLDDDDDLLL", "DUULLUUU", "UDUDDDDD", "LUUUL", "LLLLUDDD", "DULUUUUU", "ULUDDDD", "LDLLDLLDL", "UUULUUUL", "DLDD", "LULUULUL", "LULUL", "DUDUUUUU", "DLLLLULL", "LLLLLLDDLLLLLL", "DDDUDDD", "DLLLLLLDLL", "LLLLLLLLLLLLDL", "LUUULLUU", "DDLLLLLLLLLLDD", "LLLLLLLLLSLLLLLLL", "UDDDDDUU", "LLLLDLLDDDD", "DULLULUU", "LLLLLLSS", "DULLLLUU", "LLLLDDDLLLLL", "DLUULUUU", "LLLLLLLLLLLSLLLLLLL", "UDLDLD", "DUDDDDDD", "UUUDDDLL", "LDLLDLLLLL", "LLLDDDLLLLLLL", "LDLDLLLLLL", "DLULLLUU", "LLLLSS", "LLLLLLLLSDDD", "UUUUUUUUUUUUUUU", "LLLLLLDDLLLLL", "UUDUUUU", "DLULLUUU", "LLLDLLDDDD", "SLLLLLS", "ULULULUD", "LLLLLLDDDDLL", "DDDDLLLLDDD", "LLLLUUU", "UUUDULLL", "DULULL", "LLLLLLLDLLLLL", "LLLUULLL", "LLLLLLULLLLLLLLL", "LLLLLLLLSLL", "UUUUUUUUUUDD", "LLLULLLD", "LDLDDDDL", "LLUUUULL", "ULLDDDLL", "LDLDLDLLL", "LLLLLLLLLDLLLL", "ULULDDD", "LLLLLDLDLL", "LLLLLLLLLLDLLLL", "UDDUDDU", "DLLUUL", "ULLLULLLLLLL", "DDDDDULL", "LLLLLLLLLLLLLSDD", "DLLLLUUL", "LUULU", "DLUUUUUL", "DDDULLLLL", "LLLLLLLLDDDL", "DUUUUULL", "DLUUL", "LLLLLLUUUUUUUU", "LLDDLLDDD", "ULDDDDDDDDDD", "LLLLLLDU", "DLULUULL", "DDDUL", "SLLLLLLLL", "LLUUUUUU", "DLUULLUU", "LLLLLLSLLLLLLLLL", "LLSLLLLLLLL", "UUUDDDLD", "LLLSLLLLLLLL", "LLLLSLLLLLLLLL", "DDUDDDDD", "DLLDLLLLLL", "LULLLLLLDD", "DDLLDDLLL", "LDDLLLLDL", "LLLLLLLDDDLL", "DLLUUUUU", "LLLDLLLLDL", "ULLLLDLD", "DLLLUULU", "LLLLDDDU", "LLLLLLLLLSD", "DLUUUULU", "DLLLLDDLL", "LULLLLLU", "DLLUULUL", "UULLU", "LLLLLLLLLLLSL", "LDLDLDLDLDLDLDLD", "DLLLUL", "ULUUUD", "DLDDDDDL", "ULLLDLLD", "LLLDLLLDLLLD", "DLDLDDLD", "LLLDDDDLLLLLLLL", "LLLLLDDU", "LLLLLLLLSDDDD", "LLDDLLLLD", "DLULLULU", "LLLULLLU", "LLLU", "ULLLLLDS", "LLLLLLLLDLLLLLLLL", "UULLLLD", "DLDUU", "DLULUUUU", "UUDDDDDU", "LLULUD", "LLLLLLULLLDD", "LDLLLLLDLL", "UUUULLLD", "LLLLLLLLLLLLLLLLLLD", "DDUDDU", "DUUUUD", "DLLULUUU", "DDUDDDD", "LSSL", "UULDUU", "LLDDDDLLDDDD", "UDDDDUU", "DDDDDDDDULLLL", "UUUUDDDDDDD", "LLULLLLU", "DLULLUUL", "USLLLLLDDDD", "LLLLLLLDS", "LLLLLLLLDLLLLL", "LLLLLLLLLLDLL", "ULLLLLLLDDDDD", "LLLLLLLLLLSL", "LDDDDLDL", "UUUULLL", "LLLSL", "LLLLDDDDDDDDLLLL", "ULLLLLS", "ULLLLDUL", "DDDUDDDU", "LLUDLU", "UUUDUDD", "DDDDLLLLLLLLDDDD", "DDLLLLLU", "DLLLLLLLLLLLL", "LUULLLUU", "LLULLLL", "UUULU", "UUDDUUU", "LLLDDDDLLLLLLL", "DDDLLLLLLDD", "LLLDLLLLDD", "DULLD", "DLULLL", "DUUUDUUU", "LLDLLLDDDD", "LLLLLLLLLLLLLLLLLLLDD", "LLLLLLLDDDDDDDDDD", "LDLLLLLDD", "LLUULLLL", "UUULLLD", "UUUUUDDDDDDDD", "LDLDLDLDLL", "DDDDDDUUUUU", "DDDDDDDLD", "UDLLL", "UUDDLLLL", "UUDDDDU", "LULLLULL", "DDDDDDDLU", "DLULLU", "LLLLLLLLDDLLL", "LLLLULUU", "DLULLLUL", "LLLDDLLLLD", "DLULL", "DLDLDLDLL", "LLLLLLLLLLLLLLLLLLLLLLLLLL", "DULDL", "ULLLUDDDD", "ULLLDU", "DDDLLLLDDDD", "DULUUU", "DDDUUUDD", "ULLLLDDU", "SDDDDDDS", "LLLUD", "DUULLU", "DLLULUUL", "LDDDDLLLL", "LLLLLLLUUUUUU", "LLLLLLLLLLDLLL", "LDDDDDLD", "LDLLLLLLDL", "DULLUL", "UDULLLLL", "DDUDD", "DLUULUUL", "LLLLDDDDU", "DUUUUDUU", "LLLLDDDDLLLLL", "LLLUUULL", "LLLLLLLLULLLL", "DUUDUUUU", "LDDDLDDDD", "LLLLLLLLLLLSLL", "ULDLLLLU", "DLUULULU", "LDDDLDL", "ULLLLLDU", "LUUUUULL", "LLDULL", "LLLLULLLL"];
    Constants.blacklistedSubstrings = ["12345678", "password", "23456789", "11198", "land", "blue", "04199", "07199", "02199", "06199", "08199", "angel", "10199", "09199", "12199", "11199", "01197", "05197", "07197", "a199", "04197", "03197", "10197", "08197", "123123", "12197", "06197", "master", "dragon", "09197", "fish", "02197", "black", "11197", "a200", "2112", "fire", "mike", "baby", "pussy", "line", "test", "mark", "cher", "wood", "mama", "bear", "cool", "ling", "anne", "fred", "illa", "a198", "anti", "alle", "marc", "monkey", "life", "man1", "dick", "ness", "good", "daniel", "sexy", "o123", "time", "assi", "gold", "shan", "shadow", "rain", "ters", "alli", "ford", "play", "mont", "anta", "mine", "qazwsx", "ache", "stra", "erry", "michael", "dima", "green", "sher", "nick", "shar", "wolf", "ring", "killer", "suck", "tina", "robert", "01196", "even", "elin", "aris", "2211", "dark", "bird", "jordan", "paul", "1108", "scar", "ones", "lock", "123321", "0909", "arri", "mustang", "rose", "shit", "asta", "money", "121212", "0505", "arch", "03196", "football", "stro", "hill", "01019", "letmein", "dman", "chin", "10219", "04196", "05196", "amil", "pant", "baseball", "porn", "david", "james", "onic", "eron", "10419", "mini", "stal", "ison", "abc123", "lover", "ander", "alen", "30319", "t123", "erin", "ina1", "vers", "0303", "ings", "martin", "mega", "olly", "ante", "hello", "11119", "0108", "90519", "00119", "08196", "21219", "shka", "10196", "hunter", "30119", "40419", "00319", "30219", "02196", "yboy", "666666", "10619", "1102", "vlad", "70719", "pers", "1211", "nova", "12196", "10919", "anni", "sara", "lian", "010119", "07196", "30419", "0707", "elli", "oker", "50219", "er123", "atch", "00519", "00419", "rest", "06196", "50319", "side", "na19", "60619", "1107", "50419", "1210", "00619", "50819", "80319", "11196", "90919", "1109", "tran", "arma", "anton", "30519", "50719", "andrew", "l123", "09196", "50119", "31019", "enny", "0808", "40219", "90619", "01119", "80219", "34567890", "fuckyou", "70219", "00719", "40519", "anch", "sweet", "30719", "80519", "51219", "40619", "80419", "soccer", "21119", "2108", "00819", "70419", "60319", "1204", "60519", "80819", "1205", "1002", "elly", "race", "00919", "7777777", "60219", "stic", "steve", "40319", "70519", "west", "41019", "90419", "30619", "thomas", "01219", "51019", "boob", "tche", "30819", "less", "assa", "60719", "allo", "ital", "poli", "light", "50919", "lion", "30919", "50619", "90319", "70319", "2109", "80119", "ment", "70919", "70119", "60419", "60119", "40719", "40819", "81219", "80719", "0404", "70819", "1208", "0112", "31219", "0107", "asti", "90119", "harley", "each", "70619", "40119", "51119", "0304", "80619", "90719", "bone", "well", "41219", "0606", "80919", "71019", "10101", "1206", "phil", "0105", "brand", "1209", "61219", "1202", "90819", "1105", "696969", "71119", "lick", "ista", "11111111", "91019", "lisa", "more", "0110", "1005", "123qwe", "91219", "1106", "alis", "60819", "0106", "60919", "1000", "41119", "stre", "arry", "1207", "llin", "1007", "charlie", "enko", "40919", "1203", "1004", "k123", "1110", "31119", "71219", "long", "61019", "buster", "apple", "1003", "wing", "91119", "ivan", "1123", "reat", "1103", "81019", "61119", "tori", "0506", "batman", "stri", "2212", "anov", "sion", "2107", "leon", "1104", "81119", "isha", "2102", "a197", "power", "summer", "superman", "anya", "qwertyui", "sing", "3108", "pepper", "1312", "2311", "george", "ence", "nker", "lore", "2110", "tech", "alan", "3112", "87654321", "1006", "card", "2106", "1008", "part", "ryan", "ross", "123a", "liver", "amin", "gran", "1402", "cock", "aron", "william", "ssie", "gene", "2512", "2301", "01200", "elan", "ipper", "ding", "para", "rish", "maria", "nson", "dave", "frank", "sasha", "1311", "2103", "moon", "rill", "buck", "tigger", "amel", "mara", "hand", "2105", "1812", "ollo", "2309", "roni", "kate", "1512", "happy", "2525", "2505", "0405", "1301", "21985", "redd", "2202", "arth", "terr", "iloveyou", "hockey", "2310", "mper", "2501", "2210", "3012", "per1", "2206", "adam", "3107", "abri", "tron", "emen", "0123", "olli", "11991", "isto", "game", "cent", "1009", "3110", "2305", "achi", "arta", "emin", "21990", "1310", "ladi", "hawk", "gfhjkm", "moni", "21989", "gate", "ines", "ing1", "lone", "llen", "ania", "elis", "mary", "alina", "2412", "ardo", "tall", "itte", "crea", "mani", "2204", "indi", "dogg", "1478", "shel", "0502", "0305", "tree", "ning", "ation", "peter", "real", "scott", "miss", "ucki", "sant", "slav", "liza", "erna", "3010", "olle", "2510", "oria", "enne", "meli", "asca", "0308", "0708", "chie", "access", "1510", "reds", "bass", "justin", "esse", "sche", "1305", "0508", "roll", "1412", "jxrf", "2511", "sman", "2104", "1504", "0905", "niko", "hammer", "arre", "ender", "2303", "erto", "0507", "hall", "1410", "2207", "2410", "1502", "1501", "svet", "sama", "2203", "1303", "ingo", "bitch", "1308", "2205", "1503", "esta", "0501", "1511", "98765432", "1404", "222222", "112233", "2503", "ress", "m123", "2504", "0212", "pres", "2304", "f123", "ming", "lucky", "lass", "fuckme", "jessica", "1307", "1306", "lash", "1302", "0211", "an19", "tlan", "jennifer", "1405", "link", "acker", "2306", "0306", "ener", "harr", "0301", "0503", "0302", "marl", "1235", "0509", "0809", "wild", "1612", "21984", "lori", "1411", "2411", "cola", "ger1", "andrea", "1221", "21992", "0310", "avis", "0803", "snow", "came", "3003", "1507", "illo", "mist", "sandr", "cand", "rate", "1711", "silver", "hant", "1508", "daddy", "3001", "franc", "unny", "90219", "taylor", "1304", "2401", "ashi", "3004", "freedom", "1704", "3105", "dead", "2208", "2509", "0607", "amanda", "0307", "joshua", "11984", "1805", "arie", "asse", "1403", "trin", "2209", "1705", "yman", "rett", "kell", "jeff", "0609", "inst", "2502", "stas", "matthew", "lanc", "0608", "2507", "alia", "1605", "0406", "alie", "2404", "tana", "bble", "ngle", "21991", "1801", "2307", "face", "stone", "1611", "1309", "1408", "2606", "hone", "1401", "mash", "anas", "mann", "aren", "wertyuio", "son1", "2508", "8888888", "00219", "3006", "0504", "nicole", "1712", "1213", "1707", "poop", "1407", "asper", "3103", "dallas", "erri", "dream", "denis", "teri", "2805", "mina", "ader", "diamond", "ride", "eral", "asshole", "0912", "ashley", "team", "cheese", "bobb", "2506", "1406", "1710", "11983", "thunder", "ister", "hero", "roman", "er19", "2405", "chen", "3005", "21983", "n200", "ginger", "serge", "0908", "2707", "kiss", "1811", "1604", "2406", "smoke", "0309", "lord", "maggie", "trustno1", "2611", "1509", "mila", "wall", "2601", "s200", "pack", "1802", "arme", "trac", "1703", "2909", "0311", "44444", "orne", "2812", "1606", "arne", "i123", "dude", "2711", "cookie", "1702", "2308", "kara", "0512", "sere", "1706", "sunshine", "holl", "tell", "1601", "2403", "101198", "1803", "ertyuiop", "wind", "2801", "1610", "2802", "1603", "2701", "ers1", "anny", "2612", "21982", "ound", "radi", "1506", "nman", "0407", "arro", "0408", "0510", "stat", "mail", "11992", "1804", "0807", "2808", "1602", "1810", "east", "2703", "2811", "nika", "enda", "astr", "barb", "victor", "osto", "abel", "2710", "2905", "ember", "0709", "1806", "ckle", "0711", "1409", "2901", "0312", "1808", "ker1", "2605", "rena", "arke", "olga", "n199", "colo", "0410", "ckie", "rach", "2904", "2603", "0403", "dina", "2704", "2803", "alon", "corn", "2712", "ally", "papa", "0906", "anthony", "otte", "icks", "rona", "0704", "2804", "audi", "2810", "0702", "2602", "iner", "cart", "2604", "11982", "reak", "2702", "russ", "bron", "tain", "0605", "0910", "hbyf", "1709", "pimp", "bond", "03200", "ristin", "1608", "0602", "devil", "2903", "shot", "phan", "08200", "etro", "2610", "05200", "1230", "lant", "2402", "house", "aran", "ana1", "enter", "mali", "slan", "2408", "2407", "01195", "erse", "ardi", "159753", "gust", "cali", "kova", "azer", "e200", "1222", "chil", "andra", "2705", "0610", "chelsea", "princess", "0902", "1809", "ermi", "2607", "ango", "oose", "0710", "3007", "hack", "atan", "0402", "11980", "0511", "04200", "adri", "0401", "on12", "nokia", "lady", "0805", "onde", "0601", "0412", "z123", "essa", "0603", "0810", "plan", "0411", "michelle", "maks", "inde", "2906", "blow", "nasty", "0701", "computer", "aine", "mira", "ucks", "core", "2912", "qwerty1", "2409", "1708", "lson", "aint", "0812", "0911", "2709", "1609", "toni", "iron", "eave", "1088", "ture", "oner", "some", "0705", "tere", "onta", "skin", "vent", "3009", "fast", "merlin", "4123", "1807", "0706", "0802", "0901", "1607", "2910", "0806", "0904", "11981", "atur", "02200", "09200", "2911", "tten", "elena", "0612", "white", "manu", "zxcvbnm", "yankees", "0604", "blin", "ammy", "2907", "samm", "0001", "nica", "acha", "2609", "starwars", "oleg", "1018", "2807", "0801", "alls", "water", "12200", "guitar", "boom", "tara", "0409", "0611", "0804", "mate", "2809", "nell", "rton", "boot", "ffff", "vill", "2708", "bles", "maxim", "ster1", "3008", "eeee", "0907", "flor", "riel", "rebe", "maha", "lton", "2468", "berg", "0712", "2806", "chicken", "tony", "jackson", "tick", "cham", "igma", "avel", "anut", "ales", "lane", "ichi", "2608", "nche", "welcome", "0903", "2706", "ckers", "lari", "onne", "inka", "apri", "kari", "dann", "07200", "adis", "10200", "call", "pion", "london", "pink", "ddie", "0703", "erson", "sport", "eren", "peac", "1qaz2wsx", "11200", "1029", "03195", "beer", "lala", "sssss", "metal", "opper", "ydog", "brown", "carol", "buff", "r200", "amor", "ennis", "cros", "brad", "2424", "init", "anes", "frog", "esto", "06200", "igor", "fant", "21993", "12011", "13579", "ncc1701", "cast", "eddy", "rush", "n198", "rris", "stel", "05195", "kins", "11993", "enta", "0000000", "magic", "kman", "vert", "10195", "2908", "4789", "ease", "tera", "arsenal", "0811", "them", "erre", "rter", "1100", "21980", "5150", "rome", "6123", "sham", "1194", "lman", "bigdog", "brian", "uffy", "jake", "greg", "poll", "moto", "aser", "21981", "rando", "rash", "8963", "ooke", "sparky", "oger", "jason", "wwww", "golfer", "jane", "arat", "eagles", "rado", "ping", "scooter", "assword1", "medi", "lera", "poke", "nett", "arge", "sten", "high", "cont", "ddog", "user", "ambo", "anim", "phoenix", "3344", "nity", "mars", "oren", "ashe", "octo", "orma", "work", "stud", "conn", "2369", "coll", "der1", "spider", "7896", "onte", "y200", "teen", "elvi", "sting", "hanna", "lips", "rida", "marina", "yama", "term", "tigers", "kenn", "brit", "10203", "anad", "ooper", "08195", "atte", "bast", "vika", "billy", "ferrari", "ishi", "kkkk", "river", "tttt", "llar", "lakers", "rend", "04195", "11195", "able", "rita", "trip", "nice", "ilan", "barn", "seve", "usty", "bbie", "boss", "dash", "iris", "itan", "sana", "cass", "ka19", "nina", "feli", "soni", "anil", "ussi", "aram", "ampi", "ablo", "olla", "ton1", "toma", "gman", "rama", "02195", "spri", "isco", "rack", "mers", "admi", "lade", "olan", "333333", "inal", "tani", "1089", "1078", "lana", "temp", "lly1", "unner", "09195", "adin", "12195", "9090", "rent", "man2", "honda", "tany", "na12", "131313", "4545", "jami", "nake", "r1234", "ples", "acki", "vova", "back", "ghbdtn", "g123", "hema", "estr", "onald", "stia", "5252", "book", "cccc", "dale", "secret", "1515", "anis", "mana", "anal", "rell", "rion", "1415", "corvette", "emil", "madd", "tink", "icky", "h123", "103198", "tine", "surf", "ssan", "bang", "speed", "1128", "onnie", "bubba", "23232", "best", "iant", "lter", "hhhh", "nathan", "gent", "gina", "vera", "eart", "riss", "apol", "marine", "llis", "ager", "9999999", "spec", "renc", "q1w2e3r4", "lley", "llll", "07195", "arad", "mous", "iann", "rola", "iter", "aper", "fylh", "slayer", "anet", "erpo", "trav", "carlo", "rrrr", "orange", "lent", "herm", "spir", "cana", "1232", "kola", "adim", "01010", "alexand", "1414", "ass1", "alic", "mish", "a196", "mily", "drum", "ter2", "smith", "11979", "tits", "asia", "acka", "21994", "dger", "r199", "moll", "ores", "egor", "ishe", "x123", "tyle", "rangers", "osta", "alpha", "haha", "jesus", "wer1", "herr", "nders", "020219", "clar", "buddy", "olas", "tian", "lovem", "vfvf", "rney", "ley1", "mans", "oopy", "rami", "orth", "lice", "ttie", "mero", "babe", "o200", "carr", "barr", "lder", "brook", "klas", "nikita", "acer", "anic", "2334", "21978", "open", "er20", "er11", "ina2", "cowboys", "mano", "an123", "read", "anit", "bara", "rsch", "iber", "ties", "gian", "field", "obby", "q123", "outh", "ilia", "anci", "anga", "na20", "32323", "down", "ravi", "ktor", "llan", "ine1", "bren", "112198", "amat", "21979", "beat", "3141", "ndia", "11978", "solo", "road", "alma", "amma", "steph", "internet", "nich", "bbbbb", "nite", "vita", "arde", "form", "rans", "ndro", "austin", "enna", "mall", "bloo", "ants", "107198", "endo", "1087", "valer", "icia", "mack", "ommy", "anana", "erbo", "simp", "dent", "arty", "1191", "mach", "asha1", "cris", "appe", "simon", "nard", "alker", "lovel", "arga", "icker", "06195", "mela", "music", "teme", "bigg", "chik", "ler1", "bite", "rocke", "nkin", "ver1", "lica", "domin", "geni", "105198", "aska", "izard", "coco", "banan", "tomm", "11994", "tasha", "gang", "anka", "pook", "petr", "101199", "stya", "oone", "illie", "inner", "adma", "icho", "iman", "donn", "0100", "5123", "inky", "etta", "123654", "gand", "tewa", "9632", "slut", "maverick", "lama", "amber", "mala", "ksan", "mona", "mino", "ddddd", "bart", "8097", "eres", "lolo", "qazxsw", "arks", "olina", "scha", "brie", "8098", "ugar", "richard", "here", "ntan", "hamp", "ysta", "marg", "mmmmm", "01020", "crazy", "oles", "soft", "wins", "drey", "ney1", "pire", "gera", "3000", "serv", "eddi", "mercedes", "alte", "1321", "dust", "020319", "020419", "spank", "unda", "1017", "qweasd", "erbe", "yfcn", "magn", "shor", "horse", "aaaaaaa", "bern", "reme", "lett", "snoop", "artem", "egas", "guar", "plat", "bandit", "nsta", "2580", "rdon", "s199", "108198", "dona", "horny", "asil", "ordo", "nny1", "1472", "hear", "walk", "abbi", "otto", "baba", "8912", "ickl", "boog", "inha", "erica", "ical", "1028", "10120", "1098", "kota", "ican", "dest", "harm", "raci", "onco", "rice", "evel", "789456", "qwas", "post", "tard", "atar", "unch", "aleks", "arah", "hers", "whatever", "amba", "guin", "ellow", "mode", "1q2w3e", "doug", "natas", "ffin", "8050", "tele", "winn", "1593", "202198", "burn", "a111", "steelers", "lvin", "nada", "veta", "erti", "nna1", "madi", "ulle", "zzzzzz", "ena1", "duck", "4242", "indo", "oron", "matrix", "fhby", "11995", "020819", "9119", "andal", "hoot", "eway", "abcde", "deli", "chas", "issi", "pand", "iden", "orte", "list", "rost", "laster", "punk", "nior", "heri", "polo", "nand", "kitty", "butter", "rini", "cking", "110198", "yana", "olive", "start", "linda", "1090", "pala", "051987", "21977", "1717", "chuc", "rule", "020519", "nima", "entr", "ailey", "ador", "haro", "turn", "eder", "atti", "brea", "koff", "hans", "vero", "mati", "julia", "arce", "izza", "7891", "fucker", "011990", "orri", "erik", "leas", "mother", "natali", "thead", "arco", "rant", "erta", "b123", "020119", "gator", "heel", "ard1", "grea", "anat", "mer1", "vfrc", "020619", "olden", "ick1", "help", "bbit", "mera", "akot", "pool", "erst", "erni", "8951", "inch", "lame", "nchi", "death", "5555555", "1058", "kati", "011987", "aras", "lexi", "rrie", "ierr", "mili", "dboy", "ates", "kristi", "perf", "case", "bean", "asto", "randy", "oris", "iles", "falcon", "1516", "5050", "llio", "nati", "inni", "91989", "anki", "rame", "kevin", "207198", "a2010", "lest", "a123456", "rega", "friend", "chevy", "aval", "andon", "red1", "verp", "lava", "omar", "kiri", "as12", "cara", "amir", "olit", "hani", "annon", "tive", "okey", "nther", "1092", "estin", "ickey", "204198", "11977", "unit", "dance", "031988", "arba", "trai", "juan", "d1234", "rger", "11975", "1079", "020719", "dell", "rabb", "rmin", "thor", "rlan", "jean", "jone", "scorpio", "11976", "p123", "shal", "erlo", "nest", "hele", "5566", "en12", "want", "ayne", "est1", "erem", "issy", "208198", "ygir", "burg", "s1234", "forever", "ions", "enka", "flower", "uren", "sass", "051990", "ashk", "theb", "isse", "scho", "2119", "camp", "031987", "201198", "tima", "0012", "ophi", "les1", "rene", "9874", "late", "oome", "205198", "chip", "hica", "ento", "loves", "2131", "pace", "21976", "inke", "ction", "little", "duke", "206198", "elic", "onat", "ancer", "sala", "doll", "onik", "eria", "cord", "eanu", "chang", "gord", "kaka", "diab", "asdfghj", "elia", "1237", "umpe", "dies", "alam", "gala", "fort", "nine", "11121", "1118", "rker", "2128", "071987", "avan", "soph", "oshi", "knight", "bomb", "arra", "jimmy", "1314", "1285", "mple", "like", "imbo", "bigt", "1324", "dodge", "rchi", "fend", "ikol", "1129", "ocky", "r198", "1022", "lege", "inat", "llo1", "bber", "041988", "rade", "ebel", "kass", "robi", "elec", "hari", "aldo", "otti", "stef", "ssma", "erda", "luca", "samu", "leri", "tati", "ears", "adel", "frea", "iano", "ya19", "offe", "yell", "ochka", "geli", "esha", "15051", "dmin", "morgan", "bella", "onna", "21995", "8910", "31991", "ameri", "annah", "isla", "truck", "asmin", "071986", "020919", "anthe", "s198", "compa", "beth", "041986", "a777", "121987", "061986", "raider", "grac", "atash", "051988", "stle", "joke", "041987", "male", "4455", "driv", "tita", "051986", "nato", "amal", "0010", "3030", "patrick", "09876", "jjjjj", "charle", "item", "41984", "edog", "1290", "121986", "stop", "demon", "ious", "lissa", "cheste", "5935", "4725", "chol", "warr", "atro", "entin", "umbe", "ma19", "22011", "tata", "asan", "host", "skip", "on19", "lipp", "abra", "nish", "alib", "erro", "ench", "mpir", "1190", "1077", "10111", "10121", "dogs", "lphin", "nnet", "ippy", "berl", "71990", "llet", "011988", "junio", "203198", "41985", "arit", "71985", "cons", "ronc", "craft", "ongo", "ingl", "1086", "ka12", "iking", "81990", "ooooo", "ergi", "ritt", "hester", "10011", "031986", "cats", "brav", "011986", "7258", "2123", "k199", "lita", "81985", "011985", "0990", "johnny", "terp", "samsung", "mang", "city", "71989", "micke", "huck", "91986", "etty", "desi", "aura", "021019", "oser", "fall", "key1", "ssin", "timo", "joseph", "viki", "orgi", "061987", "world", "anja", "iabl", "hjcn", "mass", "hank", "5454", "anky", "comm", "21975", "051985", "91988", "81987", "arsh", "fami", "q2w3e4r", "051989", "obra", "twin", "011989", "gabr", "rles", "muff", "elove", "209198", "61990", "1127", "071988", "qqqqqq", "imbe", "erty12", "baile", "061988", "ilip", "rico", "dward", "rova", "erde", "ghjc", "lect", "eone", "cky1", "irina", "0019", "monster", "9357", "oster", "lish", "edwar", "3698", "shing", "inho", "idas", "1245", "01041", "shak", "1038", "ppppp", "girls", "5656", "45612", "yste", "5000", "smar", "amie", "ners", "raven", "pean", "meric", "ulie", "laure", "look", "n1234", "210198", "101987", "2344", "idge", "ymrf", "rpoo", "31985", "ffer", "081988", "viper", "tton", "thing", "031990", "choo", "101986", "41990", "oodl", "right", "miller", "31989", "evan", "onto", "bian", "eigh", "manc", "lace", "lema", "ggggg", "heather", "nnnn", "tenn", "orin", "emar", "ssio", "hort", "loui", "camaro", "squi", "carm", "31983", "061985", "8908", "inga", "2341", "kath", "7852", "kbyf", "stea", "view", "lldog", "pson", "ty123", "ris1", "ert1", "1234q", "eles", "ouch", "20011", "hman", "ova1", "arik", "dirt", "1188", "8904", "name", "ooby", "christi", "dria", "ethe", "plea", "ra19", "1080", "boro", "dako", "pain", "earl", "rple", "ocket", "deep", "livi", "elon", "01031", "1068", "61989", "sabe", "01021", "tyrj", "hark", "ontr", "rink", "vfhb", "amant", "utch", "in12", "lean", "01091", "hara", "nsto", "rocks", "e1234", "20021", "dolphi", "asda", "iell", "anin", "fghjk", "icki", "albert", "rato", "latin", "bulldo", "1082", "505198", "popo", "ceman", "eras", "dog1", "23021", "mell", "71983", "mario", "ber1", "smile", "rlos", "hane", "roke", "1016", "homer", "ntai", "xxxxxxx", "winte", "storm", "lova", "purpl", "kare", "41991", "coob", "091987", "nita", "count", "021988", "okin", "2342", "081989", "diana", "ione", "ntha", "pira", "pear", "dawg", "beav", "imal", "obbi", "aroli", "71984", "2333", "081986", "tdog", "bigbo", "rove", "erba", "blad", "bett", "usha", "ndri"];
})(Constants = exports.Constants || (exports.Constants = {}));

},{}],5:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var PasswordMeter = require("./PasswordMeter");
var Dictionaries;
(function (Dictionaries_1) {
    var Dictionaries = (function () {
        function Dictionaries() {
            var helper = PasswordMeter.PasswordMeter.instance.getHelper();
            this.blacklistDict = helper.compressedFileToDict("dictionary-blacklist1c8-compressed.txt");
            this.namesDict = helper.compressedFileToDict("dictionary-names-compressed.txt");
            this.passwordsDict = helper.compressedFileToDict("dictionary-passwords-compressed.txt");
            this.phrasesDict = helper.compressedFileToDict("dictionary-phrases-compressed.txt");
            this.englishwordsDict = helper.compressedFileToDict("dictionary-englishwords-compressed.txt");
            this.wikipediaDict = helper.compressedFileToDict("dictionary-wikipedia-compressed.txt");
            // potentialTODO shouldn't we load this?
            this.petnames = {};
            var temppetnames = ["abbey", "abby", "alex", "allie", "amber", "angel", "annie", "ashley", "baby", "bailey", "bandit", "barney", "baxter", "bear", "beau", "bella", "belle", "bentley", "blackie", "blue", "bonnie", "boomer", "boots", "bosco", "brady", "brandy", "bruno", "brutus", "bubba", "buddy", "buffy", "buster", "cali", "callie", "calvin", "casey", "casper", "cassie", "champ", "chance", "charlie", "chase", "chelsea", "chester", "chico", "chloe", "cleo", "cleopatra", "clyde", "coco", "cocoa", "cody", "cookie", "cooper", "cosmo", "daisy", "dakota", "dexter", "diesel", "dixie", "duke", "duncan", "dusty", "ella", "ellie", "elvis", "emily", "emma", "felix", "fiona", "fluffy", "frankie", "fred", "gabriel", "garfield", "george", "gigi", "ginger", "gizmo", "grace", "gracie", "guinness", "haley", "hannah", "harley", "harry", "heidi", "henry", "holly", "honey", "hunter", "isabella", "isis", "jack", "jackson", "jade", "jake", "jasmine", "jasper", "jessie", "joey", "junior", "katie", "kiki", "kitty", "kobe", "lacey", "lady", "lexi", "lexie", "libby", "lilly", "lily", "loki", "lola", "louie", "lucky", "lucy", "luke", "lulu", "luna", "maddie", "madison", "maggie", "mandy", "marley", "maximus", "maxwell", "maya", "merlin", "mickey", "midnight", "mikey", "millie", "milo", "mimi", "minnie", "misskitty", "missy", "misty", "mittens", "mocha", "molly", "moose", "morgan", "muffin", "murphy", "nala", "nikki", "oliver", "olivia", "oreo", "oscar", "otis", "patches", "peaches", "peanut", "pebbles", "penny", "pepper", "phoebe", "piper", "precious", "prince", "princess", "pumpkin", "rascal", "riley", "rocco", "rocky", "romeo", "roscoe", "rosie", "roxie", "roxy", "ruby", "rudy", "rufus", "rusty", "sabrina", "sadie", "samantha", "sammy", "sampson", "samson", "sandy", "sarah", "sasha", "sassy", "scooter", "scout", "sebastian", "shadow", "sheba", "shelby", "sierra", "simba", "simon", "smokey", "snoopy", "snowball", "socks", "sonny", "sophia", "sophie", "sparky", "spencer", "spike", "stalla", "stella", "sugar", "sunny", "sydney", "sylvester", "tabitha", "tasha", "teddy", "thomas", "tiger", "tigger", "tinkerbell", "toby", "tommy", "trixie", "tucker", "tyson", "willie", "willow", "winston", "xena", "yoda", "zeus", "ziggy", "zoey"];
            for (var i = 0; i < temppetnames.length; i++) {
                this.petnames[temppetnames[i]] = true;
            }
        }
        return Dictionaries;
    }());
    Dictionaries_1.Dictionaries = Dictionaries;
    (function () {
        PasswordMeter.PasswordMeter.instance.setDictionaries(new Dictionaries());
    }());
})(Dictionaries = exports.Dictionaries || (exports.Dictionaries = {}));

},{"./PasswordMeter":1}],6:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Helper;
(function (Helper_1) {
    var Helper = (function () {
        function Helper(jquery, lzstring, log) {
            this.$ = jquery;
            this.LZString = lzstring;
            this.log = log;
        }
        Helper.prototype.buildDict = function (words, dict) {
            for (var i = 0; i < words.length; i++) {
                // duplicates?
                dict[words[i]] = true; // add to dictionary object for optimized lookup
            }
            return words.length;
        };
        // Function to decompress a .txt file that contains correctly-formatted,
        // compressed, dictionary file data
        Helper.prototype.decompressFile = function (file) {
            var a;
            var lzstring = this.LZString;
            this.$.get(file, function (s) {
                var decompressed = lzstring.decompressFromEncodedURIComponent(s);
                a = decompressed.split(",");
            });
            return a;
        };
        // function for loading dictionaries that we use as wordlists
        // REQUIRES: path is a valid path to a txt file
        // REQUIRES: file is formatted such that there is one password per line
        // ENSURES: creates a javascript object from the given file path
        Helper.prototype.fileToDict = function (file) {
            var dict = {};
            var fBuildDict = this.buildDict;
            var log = this.log;
            this.$.get(file, function (s) {
                var words = s.split("\n"); // get as an array
                var added = fBuildDict(words, dict);
                log.debug("Loaded " + added + " words to dictionary.");
            });
            return dict;
        };
        // function for loading dictionaries that we use as wordlists
        Helper.prototype.toDict = function (s) {
            // get string as array of lines
            var words = s.split("\n");
            var dict = {};
            var added = this.buildDict(words, dict);
            this.log.debug("Loaded " + added + " words to the dictionary.");
            return dict;
        };
        // function for loading compressed dictionaries that we use as wordlists
        Helper.prototype.compressedFileToDict = function (path) {
            var dict = {};
            var fLZString = this.LZString;
            var fBuildDict = this.buildDict;
            var log = this.log;
            this.$.get(path, function (s) {
                var decompressed = fLZString.decompressFromEncodedURIComponent(s);
                var words = decompressed.split(",");
                var added = fBuildDict(words, dict);
                log.debug("Decompressed and loaded " + added + " words to the dictionary.");
            });
            return dict;
        };
        // loads a file (of passwords) to an array
        // REQUIRES: path is a valid path to a txt file
        // REQUIRES: file is formatted such that there is one password per line
        // ENSURES: creates an array from the given file path
        Helper.prototype.fileToArray = function (path) {
            var a = [];
            var log = this.log;
            this.$.get(path, function (s) {
                var pws = s.split("\n");
                for (var i = 0; i < pws.length; i++) {
                    a.push(pws[i]);
                }
                log.debug("Loaded" + pws.length + "passwords to an array.");
            });
            return a;
        };
        // Given a regular expression "rx" and an array of 1+ "passwordParts", returns
        // an object whose property "matched" is an array of all 0+ matches it found
        // and whose property "score" is the total number of characters matched (summed across all matches)
        // and whose property "revisedParts" is "parts" with all matches removed.
        // Note that when a match is removed from the middle of a part, it splits that part into 2.
        Helper.prototype.matchHelper = function (passwordParts, rx) {
            var matched = [];
            var revisedParts = [];
            var score = 0;
            for (var i = 0; i < passwordParts.length; i++) {
                var matchResult = passwordParts[i].match(rx);
                if (matchResult) {
                    for (var j = 0; j < matchResult.length; j++) {
                        score += matchResult[j].length;
                        var loc = passwordParts[i].indexOf(matchResult[j]);
                        // Check for a match at beginning
                        if (loc === 0) {
                            passwordParts[i] = passwordParts[i].substring(matchResult[j].length);
                        }
                        else {
                            revisedParts.push(passwordParts[i].substring(0, loc));
                            passwordParts[i] = passwordParts[i].substring(loc + matchResult[j].length);
                        }
                    }
                    matched = matched.concat(matchResult);
                }
                // Check if it didn't match OR there are leftovers after matching
                if (passwordParts[i].length > 0) {
                    revisedParts.push(passwordParts[i]);
                }
            }
            return {
                matched: matched,
                revisedParts: revisedParts,
                score: score
            };
        };
        // Given a "candidate" substring from a password, returns an array of objects, each of which
        // contains alternate strings with substitutions undone and their commonness
        // e.g., Given "m0nkey" this function will return [monkey]
        // Only performs substitutions if there is a letter within the preceding 2 or following 2 characters
        // Currently, we take the 10 most common substitutions.
        // Uncomment relevant parts below for the 20 most common instead.
        // leetspeak characters to reverse: 012345akuyz!&@$
        //o  0	16.2
        //i  1	7.6
        //20mostCommon	l  1	1.7
        //20mostCommon	one  1	1.2
        //20mostCommon	to  2	1.7
        //20mostCommon	too  2	1.4
        //e  3	12.4
        //for  4	6.8
        //a  4	3.1
        //s  5	2.0
        //20mostCommon	for you  4u 	0.7
        //20mostCommon	er  a		1.0
        //20mostCommon	c  k		1.2
        //o  u	2.8
        //20mostCommon	i  y		0.8
        //s  z	2.5
        //20mostCommon	i  !	1.5
        //20mostCommon	and  &	0.9
        //a  @	7.8
        //s  $	3.9
        Helper.prototype.commonSubstitutions = function (candidate) {
            var NONALPHA = new RegExp("[^A-Za-z]");
            // List alternate strings with substitutions undone
            var alternates = new Array();
            // Keep track of offsets (how much longer we made the string). 
            // If we replace 5 with s, keep the offset the same. 
            // If we replace 4 with for, add 2 to the offset since it is now 
            // two characters longer
            // Also track the frequency of the *least* common substitution in this string
            var original = {
                'candidate': candidate,
                'offset': 0,
                'commonness': 100
            };
            alternates.push(original);
            // Only substitute if there is a letter within 2 characters 
            // of what we are substituting
            for (var i = 0; i < candidate.length; i++) {
                if ((i >= 1 && this.isALetter(candidate.charAt(i - 1))) ||
                    (i >= 2 && this.isALetter(candidate.charAt(i - 2))) ||
                    (i < (candidate.length - 1) && this.isALetter(candidate.charAt(i + 1))) ||
                    (i < (candidate.length - 2) && this.isALetter(candidate.charAt(i + 2)))) {
                    // List possible substitutions
                    var replacements = new Array();
                    if (candidate.charAt(i) === '0') {
                        replacements.push({
                            'replacement': "o",
                            'commonness': 16.2
                        });
                    }
                    else if (candidate.charAt(i) === '1') {
                        replacements.push({
                            'replacement': "i",
                            'commonness': 7.6
                        });
                        //replacements.push({'replacement': "l", 'commonness': 1.7});
                        //replacements.push({'replacement': "one", 'commonness': 1.2});
                    }
                    else if (candidate.charAt(i) === '3') {
                        replacements.push({
                            'replacement': "e",
                            'commonness': 12.4
                        });
                    }
                    else if (candidate.charAt(i) === '4') {
                        replacements.push({
                            'replacement': "for",
                            'commonness': 6.8
                        });
                        replacements.push({
                            'replacement': "a",
                            'commonness': 3.1
                        });
                    }
                    else if (candidate.charAt(i) === '5') {
                        replacements.push({
                            'replacement': "s",
                            'commonness': 2.0
                        });
                    }
                    else if (candidate.charAt(i) === 'u' || candidate.charAt(i) === 'U') {
                        replacements.push({
                            'replacement': "o",
                            'commonness': 2.8
                        });
                    }
                    else if (candidate.charAt(i) === 'z' || candidate.charAt(i) === 'Z') {
                        replacements.push({
                            'replacement': "s",
                            'commonness': 2.5
                        });
                    }
                    else if (candidate.charAt(i) === '@') {
                        replacements.push({
                            'replacement': "a",
                            'commonness': 7.8
                        });
                    }
                    else if (candidate.charAt(i) === '$') {
                        replacements.push({
                            'replacement': "s",
                            'commonness': 3.9
                        });
                    }
                    var existingAlternates = alternates.length;
                    for (var j = 0; j < existingAlternates; j++) {
                        for (var k = 0; k < replacements.length; k++) {
                            var subToMake = replacements[k].replacement;
                            var newPW = alternates[j].candidate.replaceAt(i + alternates[j].offset, subToMake);
                            var howCommon = replacements[k].commonness;
                            if (alternates[j].commonness < howCommon) {
                                howCommon = alternates[j].commonness;
                            }
                            var newOffset = alternates[j].offset + replacements[k].replacement.length - 1;
                            alternates.push({
                                'candidate': newPW,
                                'offset': newOffset,
                                'commonness': howCommon
                            });
                        }
                    }
                }
            }
            for (var z = alternates.length - 1; z >= 0; z--) {
                if (alternates[z].candidate.match(NONALPHA)) {
                    alternates.splice(z, 1);
                }
            }
            return alternates;
        };
        // Given two arrays, a and b, each of *strings in decreasing length order*,
        // returns the longest string that is in both.
        // If there are multiple strings common to both, only returns the first from array a.
        // Not case sensitive.
        Helper.prototype.sortedOverlap = function (a, b) {
            for (var i = 0; i < a.length; i++) {
                for (var j = 0; j < b.length; j++) {
                    if (a[i] == b[j]) {
                        return a[i];
                    }
                }
            }
            return "";
        };
        // Returns true is a character is an uppercase or lowercase letter and false if it is not
        // Expects a single character as input. Returns false if not.
        Helper.prototype.isALetter = function (character) {
            // Make sure it's a single character
            if (character.length != 1) {
                return false;
            }
            var asciiCode = character.charCodeAt(0);
            if ((asciiCode >= 65 && asciiCode <= 90) || (asciiCode >= 97 && asciiCode <= 122)) {
                return true;
            }
            else {
                return false;
            }
        };
        return Helper;
    }());
    Helper_1.Helper = Helper;
    function boldAll(foo) {
        return foo.map(function (x) {
            return "<b>" + x + "</b>";
        });
    }
    Helper_1.boldAll = boldAll;
})(Helper = exports.Helper || (exports.Helper = {}));

},{}],7:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var PasswordMeter = require("./PasswordMeter");
var Constants = require("./constants");
var NeuralNetwork;
(function (NeuralNetwork) {
    var verboseMode = false;
    // In case neural nets don't load, don't wait to give a score
    var neverHeardFromNN = true;
    // Helper function designed to post-process neural network guess numbers
    // to account for capitalization. 
    // It scales guess numbers by 1.5 if they capitalize the first character, 
    // by 2 if they capitalize all characters, by 10 if they use any other pattern,
    // and 1 if there are no uppercase characters.
    function uppercasePredictabilityPostProcessing(pw) {
        // Start by assuming no uppercase at all
        var scalingFactor = 1;
        var allButFirstChar = pw.substr(1);
        // Check if first character is uppercase, and that no others are
        if ((pw.charAt(0) === pw.charAt(0).toUpperCase()
            && pw.charAt(0) !== pw.charAt(0).toLowerCase())
            && (allButFirstChar === allButFirstChar.toLowerCase())) {
            scalingFactor = 1.5;
            // Check if `all uppercase' (>=3 characters uppercase and no lowercase letters)
        }
        else if (pw.search(/[a-z]/) == -1) {
            // First delete all uppercase characters
            var pwNoUppercase = pw.replace(Constants.Constants.UPPERCASE_LETTERS_GLOBAL, "");
            // Check if password is now 3+ characters shorter
            if (pw.length >= (pwNoUppercase.length + 3)) {
                scalingFactor = 2;
            }
            // Check if there are uppercase characters that don't fit into those two patterns
        }
        else if (pw !== pw.toLowerCase()) {
            scalingFactor = 10;
        }
        return scalingFactor;
    }
    // Math.log10 is not universal yet
    function log10(x) {
        return Math.log(x) / Math.LN10;
    }
    // The main callback function for the neural network evaluation.
    // When it returns, it will display the rating (update the UI).
    function nnCallback(result, password) {
        // Make 10^15 guesses fill 2/3rds of meter
        var scaleToMeter = 67 / 15;
        var instance = PasswordMeter.PasswordMeter.instance;
        var UI = instance.getUI();
        var log = instance.getLog();
        result = result * uppercasePredictabilityPostProcessing(password);
        log.info(password + " is NN guess # " + result);
        neverHeardFromNN = false;
        var value = log10(result) * scaleToMeter;
        // With estimates, we can get fractional/negative guess numbers
        // for terrible passwords, so compensate to have a very small number
        if (result <= 1) {
            value = log10(1.1) * scaleToMeter;
        }
        if (isNaN(result)) {
            value = -1;
        }
        // Neural nets give infinity for empty passwords, hence check length
        if (password.length > 0 && result == Number.POSITIVE_INFINITY) {
            value = 100;
        }
        UI.setNeuralnetMapping(password, value);
        UI.displayRating(password);
    }
    // potentialTODO except for the logging, this looks exactly the same as above
    // This alternate callback function is used instead when evaluating 
    // concrete suggestions for a better password
    function nnFixedCallback(result, password) {
        // Make 10^15 guesses fill 2/3rds of meter
        var scaleToMeter = 67 / 15;
        var instance = PasswordMeter.PasswordMeter.instance;
        var UI = instance.getUI();
        var log = instance.getLog();
        result = result * uppercasePredictabilityPostProcessing(password);
        log.info("Fixed possibility " + password + " is NN guess # " + result);
        neverHeardFromNN = false;
        var value = log10(result) * scaleToMeter;
        // With estimates, we can get fractional/negative guess numbers
        // for terrible passwords, so compensate to have a very small number
        if (result <= 1) {
            value = log10(1.1) * scaleToMeter;
        }
        if (isNaN(result)) {
            value = -1;
        }
        // Neural nets give infinity for empty passwords, hence check length
        if (password.length > 0 && result == Number.POSITIVE_INFINITY) {
            value = 100;
        }
        UI.setNeuralnetMapping(password, value);
        UI.synthesizeFixed(password);
    }
    NeuralNetwork.nnFixedCallback = nnFixedCallback;
    var NeuralNetworkInterface = (function () {
        function NeuralNetworkInterface(nn, nnfixed) {
            this.nn = nn;
            this.nnfixed = nnfixed;
        }
        NeuralNetworkInterface.prototype.heardFromNn = function () {
            return !neverHeardFromNN;
        };
        return NeuralNetworkInterface;
    }());
    NeuralNetwork.NeuralNetworkInterface = NeuralNetworkInterface;
    (function () {
        var registry = PasswordMeter.PasswordMeter.instance;
        var jquery = registry.getJquery();
        var lzstring = registry.getLzstring();
        var config = registry.getConfig();
        var neuralNetworkConfig = config.neuralNetworkConfig;
        var nnFixed = new NeuralNetworkClient(nnFixedCallback, neuralNetworkConfig);
        var nn = new NeuralNetworkClient(nnCallback, neuralNetworkConfig);
        var instance = new NeuralNetworkInterface(nn, nnFixed);
        registry.setNN(instance);
    }());
})(NeuralNetwork = exports.NeuralNetwork || (exports.NeuralNetwork = {}));

},{"./PasswordMeter":1,"./constants":4}],8:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var PasswordMeter = require("./PasswordMeter");
var Helper = require("./helper");
var Constants = require("./constants");
/* ************** */
/* Rule Functions */
/* ************** */
var RuleFunctions;
(function (RuleFunctions) {
    function verifyMinimumRequirements(pw, username) {
        var registry = PasswordMeter.PasswordMeter.instance;
        var config = registry.getConfig();
        var dictionaries = registry.getDictionaries();
        var compliantColor = config.colors.compliant;
        var noncompliantColor = config.colors.noncompliant;
        var compliantSymbol = config.symbols.compliant;
        var noncompliantSymbol = config.symbols.noncompliant;
        var explanation = {};
        var compliance = {};
        if (config.length.active) {
            //   dimension 1: length (min / max)
            var minLength = config.length.minLength;
            var maxLength = config.length.maxLength;
            var compliant = false;
            var thisExplanation = "";
            // explain
            if (maxLength > 0) {
                thisExplanation = "Contain " + minLength.toString() + "-" + maxLength.toString() + " characters";
            }
            else {
                thisExplanation = "Contain " + minLength.toString() + "+ characters";
            }
            // check
            if (pw.length >= minLength && (pw.length <= maxLength || maxLength === 0)) {
                compliant = true;
            }
            // report
            if (compliant) {
                thisExplanation = "<span style='color:" + compliantColor + "'>" + compliantSymbol + thisExplanation;
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation;
            }
            thisExplanation += "</span>";
            explanation["length"] = thisExplanation;
            compliance["length"] = compliant;
        }
        //   prep for dimensions 2-4
        var hasLowercase = false;
        var hasUppercase = false;
        var hasDigits = false;
        var hasSymbols = false;
        var numClasses = 0;
        // potentialTODO greedy needed?
        if (pw.match(Constants.Constants.LOWERCASE_LETTERS_GLOBAL)) {
            numClasses++;
            hasLowercase = true;
        }
        if (pw.match(Constants.Constants.UPPERCASE_LETTERS_GLOBAL)) {
            numClasses++;
            hasUppercase = true;
        }
        if (pw.match(Constants.Constants.DIGITS_GLOBAL)) {
            numClasses++;
            hasDigits = true;
        }
        if (pw.match(Constants.Constants.SYMBOLS_GLOBAL)) {
            numClasses++;
            hasSymbols = true;
        }
        //   dimension 2: mandatory # of character classes
        if (config.classCount.active) {
            var minCharacterClasses = config.classCount.minCount;
            var maxCharacterClasses = config.classCount.maxCount;
            var thisExplanation = "";
            var compliant = false;
            // explain
            if (maxCharacterClasses === 4) {
                thisExplanation = "Use " + minCharacterClasses.toString() + "+ of the following: ";
            }
            else {
                thisExplanation = "Use " + minCharacterClasses.toString() + "-" + maxCharacterClasses.toString() + " of the following: ";
            }
            thisExplanation += "uppercase letters; lowercase letters; digits; symbols";
            // check
            if (numClasses >= minCharacterClasses && numClasses <= maxCharacterClasses) {
                compliant = true;
            }
            // report
            if (compliant) {
                thisExplanation = "<span style='color:" + compliantColor + "'>" + compliantSymbol + thisExplanation;
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation;
            }
            thisExplanation = thisExplanation += "</span>";
            explanation["classCount"] = thisExplanation;
            compliance["classCount"] = compliant;
        }
        //   dimension 3: mandatory character classes
        if (config.classRequire.active) {
            var uppercaseLettersRequired = config.classRequire.upperCase;
            var lowercaseLettersRequired = config.classRequire.lowerCase;
            var digitsRequired = config.classRequire.digits;
            var symbolsRequired = config.classRequire.symbols;
            var thisExplanation = "";
            var compliant = false;
            // explain
            if (lowercaseLettersRequired) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " and a lowercase letter";
                }
                else {
                    thisExplanation = "Contain a lowercase letter";
                }
            }
            if (uppercaseLettersRequired) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " and an uppercase letter";
                }
                else {
                    thisExplanation = "Contain an uppercase letter";
                }
            }
            if (digitsRequired) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " and a digit";
                }
                else {
                    thisExplanation = "Contain a digit";
                }
            }
            if (symbolsRequired) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " and a symbol";
                }
                else {
                    thisExplanation = "Contain a symbol";
                }
            }
            // assert thisExplanation contains something?
            // not setting at least one required class is an error
            // check
            if ((!lowercaseLettersRequired || hasLowercase) &&
                (!uppercaseLettersRequired || hasUppercase) &&
                (!digitsRequired || hasDigits) &&
                (!symbolsRequired || hasSymbols)) {
                compliant = true;
            }
            // report
            if (compliant) {
                thisExplanation = "<span style='color:" + compliantColor + "'>" + compliantSymbol + thisExplanation;
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation;
            }
            thisExplanation = thisExplanation += "</span>";
            explanation["classRequire"] = thisExplanation;
            compliance["classRequire"] = compliant;
        }
        //   dimension 4: forbidden character classes
        if (config.classAllow.active) {
            var uppercaseLettersPermitted = config.classAllow.upperCase;
            var lowercaseLettersPermitted = config.classAllow.lowerCase;
            var digitsPermitted = config.classAllow.digits;
            var symbolsPermitted = config.classAllow.symbols;
            var thisExplanation = "";
            var compliant = false;
            // explain
            if (!lowercaseLettersPermitted) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " or lowercase letters";
                }
                else {
                    thisExplanation = "Not include lowercase letters";
                }
            }
            if (!uppercaseLettersPermitted) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " or uppercase letters";
                }
                else {
                    thisExplanation = "Not include uppercase letters";
                }
            }
            if (!digitsPermitted) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " or digits";
                }
                else {
                    thisExplanation = "Not include digits";
                }
            }
            if (!symbolsPermitted) {
                if (thisExplanation.length > 0) {
                    thisExplanation += " or symbols";
                }
                else {
                    thisExplanation = "Not include symbols";
                }
            }
            // assert something must not be allowed
            // check
            if ((lowercaseLettersPermitted || !hasLowercase) &&
                (uppercaseLettersPermitted || !hasUppercase) &&
                (digitsPermitted || !hasDigits) &&
                (symbolsPermitted || !hasSymbols)) {
                compliant = true;
            }
            // report
            if (compliant) {
                thisExplanation = "<span style='color:" + compliantColor + "'>" + compliantSymbol + thisExplanation;
            }
            else {
                // now explain what specific, forbidden characters they used
                var forbiddenCharactersUsed = [];
                if (!lowercaseLettersPermitted && hasLowercase) {
                    forbiddenCharactersUsed = forbiddenCharactersUsed.concat(pw.match(Constants.Constants.LOWERCASE_LETTERS));
                }
                if (!uppercaseLettersPermitted && hasUppercase) {
                    forbiddenCharactersUsed = forbiddenCharactersUsed.concat(pw.match(Constants.Constants.UPPERCASE_LETTERS));
                }
                if (!digitsPermitted && hasDigits) {
                    forbiddenCharactersUsed = forbiddenCharactersUsed.concat(pw.match(Constants.Constants.DIGITS));
                }
                if (!symbolsPermitted && hasSymbols) {
                    forbiddenCharactersUsed = forbiddenCharactersUsed.concat(pw.match(Constants.Constants.SYMBOLS));
                }
                // remove duplicates and turn spaces into words
                forbiddenCharactersUsed = forbiddenCharactersUsed.removeDuplicates();
                var spaceLocation = forbiddenCharactersUsed.indexOf(" ");
                if (spaceLocation > -1) {
                    forbiddenCharactersUsed[spaceLocation] = "[space]";
                }
                thisExplanation += " (You used <b>" + forbiddenCharactersUsed.join("</b>, <b>") + "</b>)";
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation;
            }
            thisExplanation = thisExplanation += "</span>";
            explanation["classAllow"] = thisExplanation;
            compliance["classAllow"] = compliant;
        }
        //   dimension 5: forbidden passwords
        // potentialTODO how much of this is covered by forbidPasswords?
        if (config.forbidPasswords.active) {
            // potentialTODO put this under forbidPasswords?
            var forbiddenPasswords = config.forbiddenPasswords;
            var includelargerlist = config.forbidPasswords.includeLargerList;
            var thisExplanation = "";
            var compliant = false;
            // explain
            thisExplanation = "Not be an extremely common password";
            // check
            // if it's in our small array from the config file OR,
            // assuming we included the larger list, it's on that list (case-insensitive)
            // potentialTODO use Array.contains? no strictness.
            if (pw.length === 0 || forbiddenPasswords.indexOf(pw.toLowerCase()) === -1) {
                if (includelargerlist) {
                    if (pw.length === 0 || dictionaries.passwordsDict[pw.toLowerCase()] !== true) {
                        compliant = true;
                    }
                }
                else {
                    compliant = true;
                }
            }
            // report
            // note that we are only complaining about disallowed passwords if they use one
            if (compliant) {
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation + "</span>";
            }
            if (!compliant) {
                explanation["forbidPasswords"] = thisExplanation;
            }
            compliance["forbidPasswords"] = compliant;
        }
        //   dimension 6: forbidden/permitted characters
        if (config.forbidChars.active) {
            var forbiddenChars = config.forbidChars.list;
            var thisExplanation = "";
            var compliant = false;
            // explain
            thisExplanation = "Not include the following characters: " + disallowedChars;
            // note that we are only complaining about disallowed characters if they use one
            // potentialTODO we apparently also check for ASCII
            // check
            var pwUnique = pw.removeDuplicateChars();
            var disallowedChars = "";
            for (var i = 0; i < pwUnique.length; i++) {
                if (pwUnique.charCodeAt(i) < Constants.Constants.startASCII ||
                    pwUnique.charCodeAt(i) > Constants.Constants.endASCII ||
                    forbiddenChars.indexOf(pwUnique.charAt(i)) >= 0) {
                    disallowedChars += pwUnique.charAt(i);
                }
            }
            if (disallowedChars.length === 0) {
                compliant = true;
            }
            // report
            if (compliant) {
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation + "</span>";
            }
            if (!compliant) {
                explanation["forbidChars"] = thisExplanation;
            }
            compliance["forbidChars"] = compliant;
        }
        // dimension 7: repeated consecutive characters
        if (config.repeatChars.active) {
            var repeatedCharsLimit = config.repeatChars.limit;
            var thisExplanation = "";
            var compliant = false;
            // explain
            thisExplanation = "Not repeat the same character " + repeatedCharsLimit.toString() + "+ times in a row";
            // check
            var charsRepeatedConsecutively = [];
            for (var j = (repeatedCharsLimit - 1); j < pw.length; j++) {
                var testString = pw.substring(j - repeatedCharsLimit + 1, j + 1);
                var testUnique = testString.removeDuplicateChars();
                if (testUnique.length === 1) {
                    charsRepeatedConsecutively.push(testUnique);
                }
            }
            if (charsRepeatedConsecutively.length == 0) {
                compliant = true;
            }
            // report
            if (compliant) {
                thisExplanation = "<span style='color:" + compliantColor + "'>" + compliantSymbol + thisExplanation;
            }
            else {
                thisExplanation += " (<b>" + charsRepeatedConsecutively.removeDuplicates().join("</b>, <b> ") + "</b>)";
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation;
            }
            thisExplanation += "</span>";
            explanation["repeatChars"] = thisExplanation;
            compliance["repeatChars"] = compliant;
        }
        // dimension 8: password - username comparison
        if (config.usernameDifference.active) {
            var differenceFromUsername = config.usernameDifference.limit;
            var thisExplanation = "";
            var compliant = false;
            // explain
            thisExplanation = "Not base your password around your username";
            //check
            var pwcopy = pw.toLowerCase();
            var usernamecopy = username.toLowerCase();
            // remove all occurrences of username
            while (usernamecopy.length > 0 && pwcopy.indexOf(usernamecopy) > -1) {
                pwcopy = pwcopy.substr(0, pwcopy.indexOf(usernamecopy)) +
                    pwcopy.substr(pwcopy.indexOf(usernamecopy) + usernamecopy.length);
            }
            if (usernamecopy.length == 0 || pw.length == 0 || pwcopy.length >= differenceFromUsername) {
                compliant = true;
            }
            // report
            if (compliant) {
            }
            else {
                thisExplanation = "<span style='color:" + noncompliantColor + "'>" + noncompliantSymbol + thisExplanation + "</span>";
            }
            if (!compliant) {
                explanation["usernameDifference"] = thisExplanation;
            }
            compliance["usernameDifference"] = compliant;
        }
        // potentialTODO reduce operation
        var overallCompliance = true;
        for (var item in compliance) {
            overallCompliance = overallCompliance && compliance[item];
            if (!overallCompliance)
                break;
        }
        var ret = {
            compliant: overallCompliance,
            detail: {
                compliance: compliance,
                explanation: explanation
            }
        };
        return ret;
    }
    RuleFunctions.verifyMinimumRequirements = verifyMinimumRequirements;
    function pwLength(pw) {
        /* return the number of characters in the pw along with commentary */
        var length = pw.length;
        var publicText = "";
        var sensitiveText = "";
        var reasonWhy = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var maxLength = config.length.maxLength;
        // only recommend if they can add 4+ characters without hitting the maximum length, if any
        if (length < 16 && (maxLength === 0 || length < (maxLength - 3))) {
            if (length < 10) {
                reasonWhy = "Attackers are very good at guessing passwords under 10 characters even if the passwords look random";
                publicText = "Make your password longer";
                sensitiveText = "Make your password longer than " + length + " characters";
            }
            else if (length <= 12) {
                reasonWhy = "Attackers are very good at guessing passwords containing 12 characters or fewer";
                publicText = "Make your password longer";
                sensitiveText = "Make your password longer than " + length + " characters";
            }
            else {
                reasonWhy = "In recent years, attackers have gotten much better at guessing passwords under 16 characters";
                publicText = "Consider making your password longer";
                sensitiveText = "Consider making your password longer than " + length + " characters";
            }
        }
        return {
            length: length,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText
        };
    }
    RuleFunctions.pwLength = pwLength;
    function countUC(pw) {
        /* Return a count of uppercase letters */
        var uppercaseCount = 0;
        var publicText = "";
        var sensitiveText = "";
        //var problemText = "";
        var reasonWhy = "";
        var fixedPW = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var uppercaseLettersPermitted = config.classAllow.upperCase;
        for (var i = 0; i < pw.length; i++) {
            if (pw.charCodeAt(i) >= 65 && pw.charCodeAt(i) <= 90) {
                uppercaseCount++;
            }
        }
        if (uppercaseCount < (0.15 * pw.length) && uppercaseLettersPermitted) {
            publicText = "Consider using more uppercase letters";
            sensitiveText = "Consider using ";
            sensitiveText += (uppercaseCount + 1).toString() + " or more uppercase letters";
            //if(uppercaseCount != 1) {
            //	sensitiveText+="s";
            //}
            reasonWhy = "Uppercase letters are surprisingly uncommon in passwords, which makes them hard to guess";
            var char1 = 65 + Math.floor(Math.random() * 26); // add an uppercase letter somewhere
            var loc1 = Math.floor(1 + Math.random() * (pw.length - 1)); // don't make it the first or last character since so many pws have that
            fixedPW = pw.slice(0, loc1) + String.fromCharCode(char1) + pw.slice(loc1);
        }
        return {
            count: uppercaseCount,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            fixedPw: fixedPW
        };
    }
    RuleFunctions.countUC = countUC;
    function countLC(pw) {
        /* Return a count of lowercase letters */
        var lowercaseCount = 0;
        var publicText = "";
        var sensitiveText = "";
        //var problemText = "";
        var reasonWhy = "";
        var fixedPW = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var lowercaseLettersPermitted = config.classAllow.lowerCase;
        for (var i = 0; i < pw.length; i++) {
            if (pw.charCodeAt(i) >= 97 && pw.charCodeAt(i) <= 122) {
                lowercaseCount++;
            }
        }
        if (lowercaseCount < (0.15 * pw.length) && lowercaseLettersPermitted) {
            reasonWhy = "Having variety in the types of characters you use makes your password harder to guess";
            publicText = "Consider using more lowercase letters";
            sensitiveText = "Consider using ";
            sensitiveText += (lowercaseCount + 1) + " or more lowercase letters";
            //if(lowercaseCount != 1) {
            //	sensitiveText+="s";
            //}
            var char1 = 97 + Math.floor(Math.random() * 26); // add a lower letter somewhere
            var loc1 = Math.floor(1 + Math.random() * (pw.length - 1)); // don't make it the first or last character since so many pws have that
            fixedPW = pw.slice(0, loc1) + String.fromCharCode(char1) + pw.slice(loc1);
        }
        return {
            count: lowercaseCount,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            fixedPw: fixedPW
        };
    }
    RuleFunctions.countLC = countLC;
    function countDIGS(pw) {
        /* Return a count of digits */
        var digitCount = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var digitsPermitted = config.classAllow.digits;
        for (var i = 0; i < pw.length; i++) {
            if (pw.charCodeAt(i) >= 48 && pw.charCodeAt(i) <= 57) {
                digitCount++;
            }
        }
        if (digitCount < (0.15 * pw.length) && digitsPermitted) {
            publicText = "Consider using more digits";
            reasonWhy = "Most passwords contain no digits or digits in predictable places; doing otherwise makes your password harder to guess";
            sensitiveText = "Consider using ";
            sensitiveText += (digitCount + 1) + " or more digits";
            //if(digitCount != 1) {
            //	sensitiveText+="s";
            //}
        }
        return {
            count: digitCount,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText
        };
    }
    RuleFunctions.countDIGS = countDIGS;
    function countSYMS(pw) {
        /* Return a count of symbols (non-alphanumeric characters) */
        /* Remove alphanumeric characters and return the length of what's left */
        var symbolCount = pw.replace(/[A-Za-z0-9]/g, "").length;
        ;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var symbolsPermitted = config.classAllow.symbols;
        if (symbolCount < (0.15 * pw.length) && symbolsPermitted) {
            publicText = "Consider using more symbols";
            reasonWhy = "Few passwords contain symbols, which makes passwords with symbols harder to guess";
            sensitiveText = "Consider using ";
            sensitiveText += (symbolCount + 1) + " or more symbols";
            //if(symbolCount != 1) {
            //	sensitiveText+="s";
            //}
        }
        return {
            count: symbolCount,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText
        };
    }
    RuleFunctions.countSYMS = countSYMS;
    function characterClasses(pw) {
        /* count: number of classes in pw */
        var numClasses = 0;
        var unusedClass = "";
        if (pw.match(Constants.Constants.LOWERCASE_LETTERS)) {
            numClasses++;
        }
        if (pw.match(Constants.Constants.UPPERCASE_LETTERS)) {
            numClasses++;
        }
        if (pw.match(Constants.Constants.DIGITS)) {
            numClasses++;
        }
        if (pw.match(Constants.Constants.SYMBOLS)) {
            numClasses++;
        }
        var count = numClasses;
        var publicText = "";
        var problematic = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        // potentialTODO active?
        var allow = config.classAllow;
        /* Case: only lowercase letters */
        if (!pw.match(Constants.Constants.UPPERCASE_LETTERS) &&
            !pw.match(Constants.Constants.DIGITS) &&
            !pw.match(Constants.Constants.SYMBOLS)) {
            // generate suggestion that complies with composition policy
            var allowed = [];
            var allowedjoined = "";
            if (allow.symbols) {
                allowed.push("symbols");
            }
            if (allow.digits) {
                allowed.push("digits");
            }
            if (allow.upperCase) {
                allowed.push("uppercase letters");
            }
            allowedjoined = allowed.toHumanString();
            publicText = "Add " + allowedjoined + " in unpredictable locations";
            sensitiveText = "Add " + allowedjoined + " in unpredictable locations";
            problemText = "";
            reasonWhy = "38% of passwords contain only lowercase letters, making them easy for attackers to guess";
        }
        else if (!pw.match(Constants.Constants.DIGITS) &&
            !pw.match(Constants.Constants.SYMBOLS)) {
            // generate suggestion that complies with composition policy
            var allowed = [];
            var allowedjoined = "";
            if (allow.symbols) {
                allowed.push("symbols");
            }
            if (allow.digits) {
                allowed.push("digits");
            }
            allowedjoined = allowed.toHumanString();
            publicText = "Add " + allowedjoined + " in unpredictable locations";
            sensitiveText = "Add " + allowedjoined + " in unpredictable locations";
            problemText = "";
            reasonWhy = "42% of passwords contain only letters, making them easy for attackers to guess";
        }
        else if (!pw.match(Constants.Constants.UPPERCASE_LETTERS) &&
            !pw.match(Constants.Constants.SYMBOLS)) {
            // generate suggestion that complies with composition policy
            var allowed = [];
            var allowedjoined = "";
            if (allow.symbols) {
                allowed.push("symbols");
            }
            if (allow.upperCase) {
                allowed.push("uppercase letters");
            }
            allowedjoined = allowed.toHumanString();
            publicText = "Add " + allowedjoined + " in unpredictable locations";
            sensitiveText = "Add " + allowedjoined + " in unpredictable locations";
            problemText = "";
            reasonWhy = "42% of passwords contain only lowercase letters and number, making them easy for attackers to guess";
        }
        else if (!pw.match(Constants.Constants.SYMBOLS)) {
            if (allow.symbols) {
                publicText = "Add symbols in unpredictable locations";
                sensitiveText = "Add symbols in unpredictable locations";
                problemText = "";
                reasonWhy = "Because only 1% of passwords use symbols, adding them unpredictably strengthens your password";
            }
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText
        };
    }
    RuleFunctions.characterClasses = characterClasses;
    function uppercasePredictable(pw) {
        /* Evaluate whether uppercase letters are in predictable locations */
        // score is 1 if first letter or all letters are capitalized
        var score = 0;
        var publicText = "";
        var sensitiveText = "";
        var reasonWhy = "";
        var problemText = "";
        var fixedPW = "";
        if (pw.charAt(0) === pw.charAt(0).toUpperCase() && pw.charAt(0) !== pw.charAt(0).toLowerCase()) {
            // first character is uppercase; now determine if there are others
            var allbutfirstchar = pw.substr(1);
            if (allbutfirstchar === allbutfirstchar.toLowerCase()) {
                score = 1;
                publicText = "Capitalize a letter in the middle";
                sensitiveText = "Capitalize a letter in the middle, rather than the first character";
                problemText = pw.charAt(0).escapeHTML();
                reasonWhy = "30% of people also capitalize only the first character";
                var llLocations = new Array(); // find locations of lowercase letters
                for (var i = 0; i < pw.length; i++) {
                    if (pw.charCodeAt(i) >= 97 && pw.charCodeAt(i) <= 122) {
                        llLocations.push(i);
                    }
                }
                var placeToUppercase = Math.floor(Math.random() * llLocations.length);
                fixedPW = pw.substring(0, llLocations[placeToUppercase]);
                fixedPW += pw.charAt(llLocations[placeToUppercase]).toUpperCase();
                fixedPW += pw.substring(llLocations[placeToUppercase] + 1);
            }
        }
        // test if 'all uppercase' (at least 3 characters are uppercase and there are no lowercase letters)
        if (pw.search(/[a-z]/) == -1) {
            var pwNoUppercase = pw.replace(/[A-Z]/g, ""); // delete all uppercase characters...
            if (pw.length >= (pwNoUppercase.length + 3)) {
                score = 1;
                publicText = "Mix up your capitalization";
                sensitiveText = "Mix up your capitalization, rather than capitalizing everything";
                reasonWhy = "21% of passwords also contain only uppercase letters";
                var ulLocations = new Array(); // find locations of uppercase letters
                for (var i = 0; i < pw.length; i++) {
                    if (pw.charCodeAt(i) >= 65 && pw.charCodeAt(i) <= 90) {
                        ulLocations.push(i);
                    }
                }
                var placeToLowercase = Math.floor(Math.random() * ulLocations.length);
                fixedPW = pw.substring(0, ulLocations[placeToLowercase]);
                fixedPW += pw.charAt(ulLocations[placeToLowercase]).toLowerCase();
                fixedPW += pw.substring(ulLocations[placeToLowercase] + 1);
            }
        }
        return {
            score: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            fixedPw: fixedPW,
            problemText: problemText
        };
    }
    RuleFunctions.uppercasePredictable = uppercasePredictable;
    function digitsPredictable(pw) {
        /* Evaluate whether digits are in predictable locations */
        /* score 1 if yes */
        /* score 0 otherwise */
        var score = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var fixedPW = "";
        var deltas = []; // we use this to annotate where we've changed things in our fixedpw
        var NONDIGITS = new RegExp("[^0-9]");
        // potentialTODO requires following nondigits
        var DIGITSFIRST = new RegExp("^[0-9]+[^0-9]+$");
        var DIGITSLAST = new RegExp("^[^0-9]+[0-9]+$");
        if (pw.length >= 4 && !pw.match(NONDIGITS)) {
            score = 1;
            publicText = "Add more letters and symbols to your password";
            sensitiveText = "Add characters other than digits to your password";
            problemText = pw.escapeHTML();
            reasonWhy = "35% of people also use only digits";
            // potentialTODO what classes do we allow?
            // choose a random non-digit
            var char1 = 58 + Math.floor(Math.random() * (126 - 58));
            var loc1 = Math.floor(1 + Math.random() * (pw.length - 1)); // don't make it the first or last character since so many pws have that
            fixedPW = pw.slice(0, loc1) + String.fromCharCode(char1) + pw.slice(loc1);
            for (var i = 0; i < fixedPW.length; i++) {
                deltas[i] = 0;
            }
            deltas[loc1] = 1;
        }
        else if (pw.length >= 4 && pw.match(DIGITSFIRST)) {
            score = 1;
            sensitiveText = "Consider inserting digits into the middle, not just at the beginning";
            publicText = "Consider inserting digits into the middle";
            reasonWhy = "10% of people also put digits at the beginning of the password";
            var firstNonDigit = 1; // find first non-digit
            while (pw.charCodeAt(firstNonDigit) >= 48 && pw.charCodeAt(firstNonDigit) <= 57) {
                firstNonDigit++;
            }
            problemText = pw.slice(0, firstNonDigit).escapeHTML();
            // move digits somewhere in the middle
            var loc1 = Math.floor(firstNonDigit + 1 + Math.random() * (pw.length - firstNonDigit - 1));
            fixedPW = pw.slice(firstNonDigit, loc1) + pw.slice(0, firstNonDigit) + pw.slice(loc1);
            for (var i = 0; i < (loc1 - firstNonDigit); i++) {
                deltas[i] = 0;
            }
            for (var i = (loc1 - firstNonDigit); i < loc1; i++) {
                deltas[i] = 1;
            }
            for (var i = loc1; i < fixedPW.length; i++) {
                deltas[i] = 0;
            }
        }
        else if (pw.length >= 4 && pw.match(DIGITSLAST)) {
            score = 1;
            sensitiveText = "Consider inserting digits into the middle, not just at the end";
            publicText = "Consider inserting digits into the middle";
            reasonWhy = "38% of people also put digits at the end of the password";
            var lastNonDigit = pw.length - 2; // find last non-digit
            while (pw.charCodeAt(lastNonDigit) >= 48 && pw.charCodeAt(lastNonDigit) <= 57) {
                lastNonDigit--;
            }
            problemText = pw.slice(lastNonDigit + 1).escapeHTML();
            // move digits somewhere in the middle
            var loc1 = Math.floor(1 + Math.random() * (pw.length - lastNonDigit - 1));
            fixedPW = pw.slice(0, loc1) + pw.slice(lastNonDigit + 1) + pw.slice(loc1, lastNonDigit + 1);
            for (var i = 0; i < loc1; i++) {
                deltas[i] = 0;
            }
            for (var i = loc1; i < (loc1 + pw.slice(lastNonDigit + 1).length); i++) {
                deltas[i] = 1;
            }
            for (var i = (loc1 + pw.slice(lastNonDigit + 1).length); i < fixedPW.length; i++) {
                deltas[i] = 0;
            }
        }
        return {
            score: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            fixedPw: fixedPW,
            problemText: problemText,
            deltas: deltas
        };
    }
    RuleFunctions.digitsPredictable = digitsPredictable;
    function symbolsPredictable(pw) {
        /* Evaluate whether symbols are in predictable locations */
        /* score 1 if yes */
        /* score 0 otherwise */
        var score = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var fixedPW = "";
        var deltas = []; // we use this to annotate where we've changed things in our fixedpw
        var LETTERSSYMBOLSDIGITS = new RegExp("^[A-Za-z]+[^0-9A-Za-z]+[0-9]+$");
        var SYMBOLSLAST = new RegExp("^[0-9A-Za-z]+[^0-9A-Za-z]+$");
        var SYMBOLS = new RegExp("[^0-9A-Za-z]+");
        if (pw.length >= 4 && pw.match(LETTERSSYMBOLSDIGITS)) {
            score = 1;
            sensitiveText = "Move symbols and digits earlier, rather than just at the end";
            publicText = "Move symbols and digits elsewhere in your password";
            problemText = (pw.match(SYMBOLS))[0].escapeHTML();
            reasonWhy = "14% of people also use letters, followed by symbols, followed by digits";
            var startOfSymbols = pw.search(SYMBOLS); // find start of symbols
            // Are we overwriting problemText to clean out special HTML characters?
            problemText = pw.slice(startOfSymbols).escapeHTML();
            // move symbols somewhere in the middle
            var loc1 = Math.floor(1 + Math.random() * (startOfSymbols - 1));
            fixedPW = pw.slice(0, loc1) + pw.slice(startOfSymbols) + pw.slice(loc1, startOfSymbols);
            for (var i = 0; i < (loc1); i++) {
                deltas[i] = 0;
            }
            for (var i = loc1; i < (loc1 + pw.slice(startOfSymbols).length); i++) {
                deltas[i] = 1;
            }
            for (var i = (loc1 + pw.slice(startOfSymbols).length); i < fixedPW.length; i++) {
                deltas[i] = 0;
            }
        }
        else if (pw.length >= 4 && pw.match(SYMBOLSLAST)) {
            score = 1;
            sensitiveText = "Move your symbols earlier, rather than just at the end";
            publicText = "Move symbols and digits elsewhere in your password";
            reasonWhy = "16% of people also put symbols only at the end of the password";
            var startOfSymbols = pw.search(SYMBOLS); // find start of symbols
            problemText = pw.slice(startOfSymbols).escapeHTML();
            // move symbols somewhere in the middle
            var loc1 = Math.floor(1 + Math.random() * (startOfSymbols - 1));
            fixedPW = pw.slice(0, loc1) + pw.slice(startOfSymbols) + pw.slice(loc1, startOfSymbols);
            for (var i = 0; i < (loc1); i++) {
                deltas[i] = 0;
            }
            for (var i = loc1; i < (loc1 + pw.slice(startOfSymbols).length); i++) {
                deltas[i] = 1;
            }
            for (var i = (loc1 + pw.slice(startOfSymbols).length); i < fixedPW.length; i++) {
                deltas[i] = 0;
            }
        }
        return {
            score: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            fixedPw: fixedPW,
            problemText: problemText,
            deltas: deltas
        };
    }
    RuleFunctions.symbolsPredictable = symbolsPredictable;
    function keyboardPatterns(pwUnfiltered) {
        /* return the number of characters contained in a keyboard pattern.
        if there are non-consecutive keyboard patterns (e.g., qwert621asdfg),
        return the sum of all characters involved in a keyboard pattern */
        pwUnfiltered = pwUnfiltered.toLowerCase(); // for ease of checking, lowercase password
        var numCharsPattern = 0;
        //var ourmap = [["`","1","2","3","4","5","6","7","8","9","0","-" ,"=",""  ],
        //		    ["", "q","w","e","r","t","y","u","i","o","p","[" ,"]","\\"],
        //		    ["", "a","s","d","f","g","h","j","k","l",";","\'","" ,""  ],
        //		    ["", "z","x","c","v","b","n","m",",",".","/",""  ,"" ,""  ]];
        // potentialTODO pairs are row, column
        var keyboard = {
            "a": [2, 1],
            "b": [3, 5],
            "c": [3, 3],
            "d": [2, 3],
            "e": [1, 3],
            "f": [2, 4],
            "g": [2, 5],
            "h": [2, 6],
            "i": [1, 8],
            "j": [2, 7],
            "k": [2, 8],
            "l": [2, 9],
            "m": [3, 7],
            "n": [3, 6],
            "o": [1, 9],
            "p": [1, 10],
            "q": [1, 1],
            "r": [1, 4],
            "s": [2, 2],
            "t": [1, 5],
            "u": [1, 7],
            "v": [3, 4],
            "w": [1, 2],
            "x": [3, 2],
            "y": [1, 6],
            "z": [3, 1],
            "0": [0, 10],
            "1": [0, 1],
            "2": [0, 2],
            "3": [0, 3],
            "4": [0, 4],
            "5": [0, 5],
            "6": [0, 6],
            "7": [0, 7],
            "8": [0, 8],
            "9": [0, 9],
            "`": [0, 0],
            "~": [0, 0],
            "!": [0, 1],
            "@": [0, 2],
            "#": [0, 3],
            "$": [0, 4],
            "%": [0, 5],
            "^": [0, 6],
            "&": [0, 7],
            "*": [0, 8],
            "(": [0, 9],
            ")": [0, 10],
            "-": [0, 11],
            "_": [0, 11],
            "=": [0, 12],
            "+": [0, 12],
            "[": [1, 11],
            "{": [1, 11],
            "]": [1, 12],
            "}": [1, 12],
            "|": [1, 13],
            "\\": [1, 13],
            ";": [2, 10],
            ":": [2, 10],
            "'": [2, 11],
            '"': [2, 11],
            ",": [3, 8],
            "<": [3, 8],
            ".": [3, 9],
            ">": [3, 9],
            "/": [3, 10],
            "?": [3, 10],
            " ": [4, 5]
        };
        // remove any characters from pwUnfiltered whose positions on the keyboard are unknown
        var pw = "";
        for (var i = 0; i < pwUnfiltered.length; i++) {
            if (typeof keyboard[pwUnfiltered.charAt(i)] !== 'undefined') {
                pw += pwUnfiltered.charAt(i);
            }
        }
        var keyvectors = new Array();
        for (var i = 1; i < pw.length; i++) {
            var deltax = keyboard[pw.charAt(i)][0] - keyboard[pw.charAt(i - 1)][0];
            var deltay = keyboard[pw.charAt(i)][1] - keyboard[pw.charAt(i - 1)][1];
            keyvectors[i - 1] = deltax.toString() + "," + deltay.toString();
        }
        var ALLDIGITS = new RegExp("^[0-9]+$");
        // find *longest* series of identical vectors... this is the longest pattern
        var longestmatchstart = 0;
        var longestmatchlength = 0;
        var seriesvector = "none";
        var currentstart = 0;
        for (var i = 0; i < keyvectors.length; i++) {
            // potentialTODO we have the inter-key vectors in keyvectors now
            var vector = keyvectors[i];
            if (vector === seriesvector) {
                // continuing the series
            }
            else {
                // a new vector, save the data of the old series if necessary
                if (i - currentstart > longestmatchlength) {
                    // longer than what we've seen so far, so save info
                    // original wanted to ignore key repeats?
                    if (vector !== "0,0") {
                        longestmatchstart = currentstart;
                        longestmatchlength = i - currentstart;
                    }
                }
                // now start a new series
                currentstart = i;
            }
            /* potentialTODO ???
            if (keyvectors[i] !== seriesvector) { // end of match
                if ((i - currentstart) > longestmatchlength &&
                !pw.substring(currentstart, currentstart + i - currentstart + 1).match(ALLDIGITS) &&
                seriesvector !== "0,0") {
                    // longer than previous long match, and also not all digits,
                    // and also not just repetition of the same character (0,0 vector)
                    longestmatchlength = i - currentstart;
                    longestmatchstart = currentstart;
                }
                currentstart = i;
                seriesvector = keyvectors[i];
            } else if (i === (keyvectors.length - 1)) {
                // not end of match, but end of pw... we need to include final character
                if ((i - currentstart + 1) > longestmatchlength &&
                !pw.substring(currentstart, currentstart + i - currentstart + 1).match(ALLDIGITS) &&
                seriesvector !== "0,0") {
                    // longer than previous long match, and also not all digits,
                    // and also not just repetition of the same character (0,0 vector)
                    longestmatchlength = i - currentstart + 1;
                    longestmatchstart = currentstart;
                }
            }
            */
        }
        //			var keyvectorsjoined = "[" + keyvectors.join("][") + "]";
        //			return keyvectorsjoined;
        var score = longestmatchlength + 1; // these are the inter-key jumps, so add 1 to get length of string
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        if (score >= 4) {
            problemText = pw.substring(longestmatchstart, longestmatchstart + longestmatchlength + 1).escapeHTML();
            publicText = "Avoid using a pattern on your keyboard";
            sensitiveText = "Avoid using a pattern on your keyboard like <b>" + problemText + "</b>";
            reasonWhy = "Because keyboard patterns are very common in passwords, attackers know to guess them";
        }
        if (score < 3) {
            score = 0;
        }
        return {
            score: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.keyboardPatterns = keyboardPatterns;
    function duplicatedCharacters(pw) {
        /* returns the total number of characters that are duplicates of characters
        used previously in the password. The repetition of characters does not need to
        be consecutive. For instance, ``zcbm'' contains 0 duplicated characters,
        ``zcbmcb'' contains 2 duplicated characters, and ``zcbmbb'' also contains 2
        duplicated characters. */
        var pw_arr = pw.split('');
        var uniques = pw_arr.removeDuplicates();
        var count = pw.length - uniques.length;
        var publicText = "";
        var sensitiveText = "";
        var reasonWhy = "";
        var problemText = "";
        if ((uniques.length <= 1 / 2 * pw.length) && uniques.length <= 5) {
            problemText = "";
            publicText = "Have more variety in the characters you choose";
            var pluralSuffix = "";
            if (uniques.length > 1) {
                pluralSuffix = "s";
            }
            var sensitiveText = "Have more variety than repeating the same " + uniques.length +
                " character" + pluralSuffix + " (" + Helper.Helper.boldAll(uniques.sort()).toHumanString() + ")";
            reasonWhy = "Passwords that use only a few different characters are easy for " +
                "attackers to guess";
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.duplicatedCharacters = duplicatedCharacters;
    function repeatedSections(pw) {
        // Checks pw for both mirrored and repeated sequences
        // Returns # characters duplicated (e.g., cmucmu returns 3, while cmucmucmu returns 6)
        // In text, gives the longest sequence (either repeated or mirrored) of length 3+
        var count = 0; // how many characters were repeated
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var backwards = false;
        pw = pw.toLowerCase(); // don't want this to be case sensitive
        var pwLength = pw.length;
        for (var len = Math.floor(pwLength / 2); len >= 3; len--) {
            // go through decreasing lengths, as long as at least 3 chars remain
            for (var start = 0; start <= (pwLength - len); start++) {
                var currentForwards = pw.substring(start, start + len);
                var currentBackwards = currentForwards.split("").reverse().join("");
                for (var i = 0; (i + len) <= start; i++) {
                    if (pw.substring(i, i + len) === currentForwards) {
                        count += len;
                        problemText = currentForwards.escapeHTML();
                    }
                    else if (pw.substring(i, i + len) === currentBackwards) {
                        count += len;
                        problemText = currentForwards.escapeHTML();
                        backwards = true;
                    }
                }
                for (var i = (start + len); (i + len) <= pwLength; i++) {
                    if (pw.substring(i, i + len) === currentForwards) {
                        count += len;
                        problemText = currentForwards.escapeHTML();
                    }
                    else if (pw.substring(i, i + len) === currentBackwards) {
                        count += len;
                        problemText = currentForwards.escapeHTML();
                        backwards = true;
                    }
                }
                if (count >= 3) {
                    if (count >= 4) {
                        publicText = "Avoid repeating sections";
                        sensitiveText = "Avoid repeating sections (<b>" + problemText + "</b>)";
                        reasonWhy = "In their guessing, attackers know to try duplicating parts of the password";
                        if (backwards) {
                            publicText += ", forwards or backwards";
                            sensitiveText += ", forwards or backwards";
                        }
                    }
                    else {
                        problemText = "";
                    }
                    break;
                }
            }
            if (count > 0) {
                break;
            }
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.repeatedSections = repeatedSections;
    function repeats(pw) {
        /* returns the number of characters in the longest string of at least 3+
        consecutive, repeated characters (e.g., ``monkeeey'' returns 3, while
        ``monkeey'' returns 0) in the password */
        var temp;
        var length = pw.length;
        var most_repeats = 1;
        var current_repeats = 1;
        var most_repeated = "";
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        for (var i = 1; i < length; i++) {
            if (pw[i - 1] == pw[i]) {
                current_repeats++;
                if (current_repeats > most_repeats) {
                    most_repeats = current_repeats;
                    most_repeated = pw[i];
                }
            }
            else {
                // not a match, reset
                current_repeats = 1;
            }
        }
        var count = most_repeats;
        if (most_repeats >= 3) {
            publicText = "Don't repeat the same character many times in a row";
            for (var j = 0; j < count; j++) {
                problemText += most_repeated;
            }
            problemText = problemText.escapeHTML();
            sensitiveText = "Don't repeat the same character (<b>" + problemText + "</b>) many times in a row";
            reasonWhy = "Hitting the same key over and over adds little to your password's strength";
        }
        if (count === 1) {
            count = 0;
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.repeats = repeats;
    function contextual(pw, form_data) {
        /* Takes a pw and an array of contextual form_data strings (e.g., from username field)
           Returns the length of the longest string of characters in the password that are from the context */
        var count = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var remaining = pw; // the password after contextual information, if any, has been removed
        // first lowercase context and passwords. do not, however, remove special chars or anything
        for (var i = 0; i < form_data.length; i++) {
            form_data[i] = form_data[i].toLowerCase();
        }
        // we don't care if <4 chars overlap
        var contextStrings = form_data.listSubstringsMinMax(5, undefined);
        var pwSubstrings = [pw.toLowerCase()].listSubstringsMinMax(5, undefined);
        var _helper = PasswordMeter.PasswordMeter.instance.getHelper();
        var longestOverlap = _helper.sortedOverlap(pwSubstrings, contextStrings);
        if (longestOverlap.length >= 5) {
            count = longestOverlap.length;
            problemText = longestOverlap.escapeHTML();
            publicText = "Don't use your account information in your password";
            sensitiveText = "Don't use your account information (<b>" + problemText + "</b>) in your password";
            reasonWhy = "Attackers know to guess your username and email address as part of your password";
            var offendingStringLocation = pw.indexOf(longestOverlap);
            if (offendingStringLocation > -1) {
                remaining = pw.substr(0, offendingStringLocation) + pw.substr(offendingStringLocation + longestOverlap.length);
            }
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText,
            remaining: remaining
        };
    }
    RuleFunctions.contextual = contextual;
    function commonSubstringCheck(pw) {
        /* this function should, given a password, return the number of characters in the
        password that are common substrings in passwords. */
        var count = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var matchedSubstrings = new Array();
        pw = pw.toLowerCase();
        var blacklistedSubstrings = Constants.Constants.blacklistedSubstrings;
        for (var i = 0; i < blacklistedSubstrings.length; i++) {
            while (pw.indexOf(blacklistedSubstrings[i]) != -1) {
                matchedSubstrings.push(blacklistedSubstrings[i]);
                // put a space in there since no substrings contain one
                // potentialTODO why not a nonprinting char?
                pw = pw.replace(blacklistedSubstrings[i], " ");
            }
        }
        if (matchedSubstrings.length > 0) {
            publicText = "Avoid strings of characters commonly found in passwords";
            var collapsed = matchedSubstrings.join(" </b>and<b> ");
            sensitiveText = "Avoid strings of characters commonly found in passwords like <b>" +
                collapsed + "</b>";
            reasonWhy = "Even if they don't make sense, these strings of characters show up in " +
                "many passwords, which makes them bad to use in yours.";
            problemText = matchedSubstrings[0].escapeHTML(); // zzz for now just give first one
            for (var j = 0; j < matchedSubstrings.length; j++) {
                count += matchedSubstrings[j].length;
            }
        }
        return {
            count: count,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.commonSubstringCheck = commonSubstringCheck;
    function commonPwCheck(listofSS) {
        /* this function should, given a list of password substrings
        return the length of the longest match on this list (case insensitive). */
        var dict = PasswordMeter.PasswordMeter.instance.getDictionaries().passwordsDict;
        var reasonWhy = "Attackers frequently use other people's common passwords as a starting point for their guesses";
        for (var i = 0; i < listofSS.length; i++) {
            if (dict[listofSS[i]]) {
                // dictionary entries are booleans
                var publicText = "Avoid using very common passwords as part of your own password";
                var sensitiveText = "Avoid using very common passwords like <b>" + listofSS[i] + "</b> as part of your own password";
                var problemText = listofSS[i].escapeHTML();
                var length = listofSS[i].length;
                // only one is enough
                return {
                    length: length,
                    reasonWhy: reasonWhy,
                    publicText: publicText,
                    sensitiveText: sensitiveText,
                    problemText: problemText
                };
            }
        }
        return {
            length: 0,
            reasonWhy: reasonWhy,
            publicText: "",
            sensitiveText: "",
            problemText: ""
        };
    }
    RuleFunctions.commonPwCheck = commonPwCheck;
    function blacklist(pw) {
        /* this function should, given a password and a set of site-specific words,
        return the number of characters in the password that are on that list of words */
        var config = PasswordMeter.PasswordMeter.instance.getConfig();
        var helper = PasswordMeter.PasswordMeter.instance.getHelper();
        // potentialTODO by config it's not a blacklist, rather a list of ignored words
        var blacklistedWords = config.ignoredWords;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var remaining = pw; // the password with any blacklisted content, if any, removed
        var wordsTheyShouldNotHaveUsed = [];
        var NONALPHA = new RegExp("[^A-Za-z]");
        // lowercase and split the password:
        pw = pw.toLowerCase();
        pw = pw.replace(/[-_ ]/g, ""); // remove characters that could delimit words
        //20mostCommon var pwParts = pw.split(/[^a-z012345!&@$]+/); // split password into parts that might contain dictionary words post-substitution; discard non-letters that won't be reverse substituted
        var pwParts = pw.split(/[^a-z01345@$]+/); // split password into parts that might contain dictionary words post-substitution; discard non-letters that won't be reverse substituted
        pwParts = pwParts.filter(function (e) {
            return e;
        }); // this removes empty strings, etc.
        var listofSS = pwParts.listSubstringsMinMax(1, undefined); // returns substrings in descending order of length
        var i = 0; // loop variable that we will sometimes reset when we re-populate this list
        while (i < listofSS.length) {
            var foundMatch = "";
            var variantsToLookUp = new Array();
            // potentialTODO magic number 14
            // don't try common substitutions for long passwords; the number of variants
            // adds up and may cause the code to hang
            if (listofSS[i].match(NONALPHA) && pw.length <= 14) {
                variantsToLookUp = helper.commonSubstitutions(listofSS[i]);
            }
            else {
                variantsToLookUp.push({
                    candidate: listofSS[i],
                    offset: 0,
                    commonness: 100
                });
            }
            for (var z = 0; z < variantsToLookUp.length; z++) {
                var currentVariant = variantsToLookUp[z].candidate;
                // in each case, look up the variant, but push the unedited text back to the user
                if (blacklistedWords.indexOf(currentVariant) > -1) {
                    wordsTheyShouldNotHaveUsed.push(listofSS[i]);
                    foundMatch = listofSS[i];
                }
            }
            if (foundMatch.length > 0) {
                if (problemText.length == 0) {
                    problemText = listofSS[i].escapeHTML();
                }
                // remove the matched substring from password parts.
                for (var z = 0; z < pwParts.length; z++) {
                    var ssLocation = pwParts[z].indexOf(foundMatch);
                    if (ssLocation > -1) {
                        pwParts.splice(z, 1, pwParts[z].substring(0, ssLocation), pwParts[z].substring(ssLocation + foundMatch.length));
                        pwParts = pwParts.filter(function (e) {
                            return e;
                        });
                        break;
                    }
                }
                var listofSS = pwParts.listSubstringsMinMax(1, foundMatch.length);
                foundMatch = "";
                i = 0;
            }
            else {
                i++;
            }
        }
        // generate list of word choices to complain to the user about
        var length = 0; // keep track of how many characters were in a wordlist
        var complaintTokens = 0; // keep track of how many separate tokens (words) were used
        if (wordsTheyShouldNotHaveUsed.length > 0) {
            publicText = "Don't use site-specific terms in your password";
            for (var i = 0; i < wordsTheyShouldNotHaveUsed.length; i++) {
                length += wordsTheyShouldNotHaveUsed[i].length;
                complaintTokens++;
                var offendingStringLocation = remaining.indexOf(wordsTheyShouldNotHaveUsed[i]);
                if (offendingStringLocation > -1) {
                    remaining = remaining.substr(0, offendingStringLocation) +
                        remaining.substr(offendingStringLocation +
                            wordsTheyShouldNotHaveUsed[i].length);
                }
            }
            sensitiveText = "Don't use site-specific terms (" + Helper.Helper.boldAll(wordsTheyShouldNotHaveUsed.removeDuplicates()).toHumanString() + ")";
            reasonWhy = "Attackers target their attacks to words used on a particular service";
        }
        return {
            length: length,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText,
            remaining: remaining
        };
    }
    RuleFunctions.blacklist = blacklist;
    function combinedDictCheck(pw) {
        /* Note: when creating the dictionaries, be sure that they are disjoint!
        This function assumes they are. Also assumes dictionary entries all contain at
        least 4 characters. Assumes all dictionaries contain only lowercase letters.
        Therefore, look for common passwords in another function. */
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var commonness = 100; // how common the most common substitution is. 100 indicates no substitution
        var RIGHTWARDS_ARROW = " &#x2192; "; // RIGHTWARDS_ARROW
        // arrays of the words to complain to users about
        var petnameArray = new Array();
        var phraseArray = new Array();
        var nameArray = new Array();
        var wikipediaArray = new Array();
        var englishwordArray = new Array();
        var registry = PasswordMeter.PasswordMeter.instance;
        var dictionaries = registry.getDictionaries();
        var helper = registry.getHelper();
        var transformationArray = new Array();
        var transformationArrayUnedited = new Array(); // store just the transformed version... use this for counting the length of the word, not the prior, which contains explanatory text
        // end
        // split the password:
        pw = pw.replace(/[-_ ]/g, ""); // remove characters that could delimit words
        var pwParts = pw.split(/[^A-Za-z012345!&@$]+/); // split password into parts that might contain dictionary words post-substitution; discard non-letters that won't be reverse substituted
        pwParts = pwParts.filter(function (e) {
            return e;
        });
        // this removes empty strings, etc.
        var listofSS = pwParts.listSubstringsMinMax(4, undefined);
        // returns substrings in descending order of length
        // loop variable that we will sometimes reset when we re-populate this list
        var i = 0;
        while (i < listofSS.length) {
            var foundMatch = "";
            var variantsToLookUp = new Array();
            var lowercasedSS = listofSS[i].toLowerCase();
            if (lowercasedSS.match(Constants.Constants.NONALPHA) && pw.length <= 14) {
                variantsToLookUp = helper.commonSubstitutions(lowercasedSS);
            }
            else {
                variantsToLookUp.push({
                    'candidate': lowercasedSS,
                    'offset': 0,
                    'commonness': 100
                });
            }
            for (var z = 0; z < variantsToLookUp.length; z++) {
                var currentVariant = variantsToLookUp[z].candidate;
                var currentCommonness = variantsToLookUp[z].commonness;
                // in each case, look up the variant, but push the unedited text back to the user
                // potentialTODO can these be coalesced?
                if (dictionaries.petnames[currentVariant]) {
                    if (variantsToLookUp[z].commonness === 100) {
                        petnameArray.push(listofSS[i]);
                    }
                    else {
                        transformationArray.push(currentVariant + " " + RIGHTWARDS_ARROW + " " + listofSS[i]);
                        transformationArrayUnedited.push(listofSS[i]);
                    }
                    foundMatch = listofSS[i];
                    if (currentCommonness < commonness) {
                        commonness = currentCommonness;
                    }
                }
                else if (dictionaries.phrasesDict[currentVariant]) {
                    if (variantsToLookUp[z].commonness === 100) {
                        phraseArray.push(listofSS[i]);
                    }
                    else {
                        transformationArray.push(currentVariant + " " + RIGHTWARDS_ARROW + " " + listofSS[i]);
                        transformationArrayUnedited.push(listofSS[i]);
                    }
                    foundMatch = listofSS[i];
                    if (currentCommonness < commonness) {
                        commonness = currentCommonness;
                    }
                }
                else if (dictionaries.namesDict[currentVariant]) {
                    if (variantsToLookUp[z].commonness === 100) {
                        nameArray.push(listofSS[i]);
                    }
                    else {
                        transformationArray.push(currentVariant + " " + RIGHTWARDS_ARROW + " " + listofSS[i]);
                        transformationArrayUnedited.push(listofSS[i]);
                    }
                    foundMatch = listofSS[i];
                    if (currentCommonness < commonness) {
                        commonness = currentCommonness;
                    }
                }
                else if (dictionaries.wikipediaDict[currentVariant]) {
                    if (variantsToLookUp[z].commonness === 100) {
                        wikipediaArray.push(listofSS[i]);
                    }
                    else {
                        transformationArray.push(currentVariant + RIGHTWARDS_ARROW + listofSS[i]);
                        transformationArrayUnedited.push(listofSS[i]);
                    }
                    foundMatch = listofSS[i];
                    if (currentCommonness < commonness) {
                        commonness = currentCommonness;
                    }
                }
                else if (dictionaries.englishwordsDict[currentVariant]) {
                    if (variantsToLookUp[z].commonness === 100) {
                        englishwordArray.push(listofSS[i]);
                    }
                    else {
                        transformationArray.push(currentVariant + RIGHTWARDS_ARROW + listofSS[i]);
                        transformationArrayUnedited.push(listofSS[i]);
                    }
                    foundMatch = listofSS[i];
                    if (currentCommonness < commonness) {
                        commonness = currentCommonness;
                    }
                }
            }
            if (foundMatch.length > 0) {
                if (problemText.length == 0) {
                    problemText = listofSS[i].escapeHTML();
                }
                // remove the matched substring from password parts.
                for (var z = 0; z < pwParts.length; z++) {
                    var ssLocation = pwParts[z].indexOf(foundMatch);
                    if (ssLocation > -1) {
                        pwParts.splice(z, 1, pwParts[z].substring(0, ssLocation), pwParts[z].substring(ssLocation + foundMatch.length));
                        pwParts = pwParts.filter(function (e) {
                            return e;
                        });
                        // that cleared out empty strings etc
                        break;
                    }
                }
                var listofSS = pwParts.listSubstringsMinMax(4, foundMatch.length);
                foundMatch = "";
                i = 0;
            }
            else {
                i++;
            }
        }
        // generate list of word choices to complain to the user about
        var publicComplaints = new Array();
        var sensitiveComplaints = new Array();
        var complaintLength = 0; // keep track of how many characters were in a wordlist
        var complaintTokens = 0; // keep track of how many separate tokens (words) were used
        var boldList = function (foo) {
            return Helper.Helper.boldAll(foo.removeDuplicates()).toHumanString();
        };
        var fillComplaints = function (array, text) {
            if (array.length > 0) {
                publicComplaints.push(text);
                for (var i = 0; i < array.length; i++) {
                    complaintLength += array[i].length;
                    complaintTokens++;
                }
                sensitiveComplaints.push(text + " (" + boldList(array) + ")");
                //sensitiveComplaints.push("names (<b>" + nameArray.removeDuplicates().join(" </b>and<b> ") + "</b>)");
            }
        };
        fillComplaints(nameArray, "names");
        fillComplaints(petnameArray, "pet names");
        fillComplaints(phraseArray, "common phrases");
        fillComplaints(englishwordArray, "dictionary words");
        fillComplaints(wikipediaArray, "words used on Wikipedia");
        fillComplaints(transformationArray, "simple transformations of words or phrases");
        if (publicComplaints.length > 0) {
            reasonWhy = "Attackers use software that automatically guesses millions of words commonly found in dictionaries, wordlists, or other people's passwords";
            publicText = "Don't use ";
            sensitiveText = "Don't use ";
            if (commonness < 100) {
                reasonWhy += ", including simple transformations of those words/phrases where they substitute digits and symbols for letters";
            }
            publicText += publicComplaints.join(" or ");
            sensitiveText += sensitiveComplaints.join(" or ");
        }
        // adjust the commonness to make the uncommon substitutions higher numbers
        // as a result of this transformation, no substitutions will be commonness 0
        // and a substitution that occurs 2% of the time will be 98
        commonness = 100 - commonness;
        return {
            length: complaintLength,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText,
            dictionaryTokens: complaintTokens,
            substitutionCommonness: commonness
        };
    }
    RuleFunctions.combinedDictCheck = combinedDictCheck;
    function identifyDates(pw) {
        /* this function should return the number of characters that appear to be part of a date
        see https://www.researchgate.net/profile/Christopher_Collins5/publication/235945835_Visualizing_semantics_in_passwords_the_role_of_dates/links/00b7d52956af68fd0c000000.pdf */
        var score = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var datesUsed = [];
        var helper = PasswordMeter.PasswordMeter.instance.getHelper();
        var passwordParts = [pw]; // as we start removing things, keep an array of the remaining parts
        var dateanalyze = function (rx) {
            var resultObj = helper.matchHelper(passwordParts, rx);
            if (resultObj.score > 0) {
                score += resultObj.score;
                datesUsed = datesUsed.concat(resultObj.matched.toString());
                passwordParts = resultObj.revisedParts;
            }
        };
        // date delimiters
        var DEL = '([ .-/])';
        // potentialTODO if we don't want to accept a single digit month, discard
        // what is after the last OR. MMDDYYYY matched on 2012020 because of this
        // though the actual date string was 20120202 (YYYYMMDD)
        var MM = '((0\\d|1[012])|\\d)';
        var MMMM = '(january|february|march|april|may|june|july|august|september|october|november|december)';
        var DD = '([012]\\d|3[01])';
        var YY = '(\\d\\d)';
        var YYYY = '(19\\d\\d|20[01234]\\d)';
        // identify dates YYYY-MM-DD with delimiters?
        // identify dates YYYYMMDD without delimiters?
        // identify dates MM-DD-YYYY with delimiters
        var rx = new RegExp(MM + DEL + DD + DEL + YYYY, "g");
        dateanalyze(rx);
        // identify dates DD-MM-YYYY with delimiters
        var rx = new RegExp(DD + DEL + MM + DEL + YYYY, "g");
        dateanalyze(rx);
        // identify dates MM-DD-YY with delimiters
        var rx = new RegExp(MM + DEL + DD + DEL + YY, "g");
        dateanalyze(rx);
        // identify dates DD-MM-YY with delimiters
        var rx = new RegExp(DD + DEL + MM + DEL + YY, "g");
        dateanalyze(rx);
        // identify dates MMDDYYYY without delimiters
        var rx = new RegExp(MM + DD + YYYY, "g");
        dateanalyze(rx);
        // identify dates DDMMYYYY without delimiters
        var rx = new RegExp(DD + MM + YYYY, "g");
        dateanalyze(rx);
        // in the future, maybe consider identifying dates MMDDYY without any delimiters, but there seem to be lots of false positives
        // identify spelled-out months and recent year (4 digits)
        var rx = new RegExp(MMMM + YYYY, "ig");
        dateanalyze(rx);
        // identify spelled-out months and recent year (2 digits)
        var rx = new RegExp(MMMM + YY, "ig");
        dateanalyze(rx);
        // identify dates MM-DD with delimiters/
        var rx = new RegExp(MM + DEL + DD, "g");
        dateanalyze(rx);
        // identify dates DD-MM with delimiters/
        var rx = new RegExp(DD + DEL + MM, "g");
        dateanalyze(rx);
        // identify recent years between 1900 and 2049
        var rx = new RegExp(YYYY, "g");
        dateanalyze(rx);
        //console.log(datesUsed);
        //console.log(passwordParts);
        if (score > 0) {
            publicText = "Avoid using dates";
            sensitiveText = "Avoid using dates like " + Helper.Helper.boldAll(datesUsed).toHumanString();
            reasonWhy = "Dates and years in any format are quite common in passwords";
            problemText = datesUsed[0].escapeHTML(); // zzz this should be an array
        }
        return {
            count: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.identifyDates = identifyDates;
    function alphabeticSequenceCheck(pw) {
        /* return the number of characters the are part of 3+ character sequences
           (e.g., abc), defined using the ASCII code for those characters. if there
           are multiple such sequences, return the sum of the number of characters
           in each. */
        var score = 0;
        var publicText = "";
        var sensitiveText = "";
        var problemText = "";
        var reasonWhy = "";
        var charCodeVector = []; // stores the charcode at position i
        var differenceVector = []; // stores the difference in character codes between subsequent characters
        charCodeVector[0] = pw.charCodeAt(0);
        for (var i = 1; i < pw.length; i++) {
            charCodeVector[i] = pw.charCodeAt(i);
            differenceVector[i - 1] = charCodeVector[i] - charCodeVector[i - 1];
        }
        var longestmatchstart = -1;
        var longestmatchlength = -1;
        var currentstart = 0;
        var currentSeqEnd = 0;
        var currentSequence = -1;
        for (var i = 0; i < differenceVector.length; i++) {
            // potentialTODO we have the inter-character vectors in differenceVector now
            var vector = differenceVector[i];
            if (vector === currentSequence) {
                // continuing the series
            }
            else {
                // a new vector, save the data of the old series if necessary
                if (i - currentstart > longestmatchlength) {
                    // longer than what we've seen so far, so save info
                    // original wanted to ignore char repeats?
                    if (vector !== 0) {
                        longestmatchstart = currentstart;
                        longestmatchlength = i - currentstart;
                    }
                }
                // now start a new series
                currentstart = i;
            }
            /*
                for (var i = 1; i < differenceVector.length; i++) {
                    if (differenceVector[i] === currentSeqDifference) { // if same, extend the current sequence
                        currentSeqEnd = i;
                    } else { // that was the end of the current sequence
                        if ((currentSeqEnd - currentSeqStart) > (longestSeqEnd - longestSeqStart) &&
                        currentSeqDifference !== 0) {
                            // if longer than previous longest and also not just a repeated sequence
                            longestSeqStart = currentSeqStart;
                            longestSeqEnd = currentSeqEnd;
                        }
                        currentSeqStart = i;
                        currentSeqEnd = i;
                        currentSeqDifference = differenceVector[i];
                    }
                }
                if ((currentSeqEnd - currentSeqStart) > (longestSeqEnd - longestSeqStart) && currentSeqDifference !== 0) { // if last one longer than previous longest and also not just a repeated sequence
                    longestSeqStart = currentSeqStart;
                    longestSeqEnd = currentSeqEnd;
                }
            
                var score = longestSeqEnd - longestSeqStart + 1;
                */
            var score = longestmatchlength;
            if (score === 1) {
                score = 0;
            }
            if (score >= 2) {
                score++;
            }
            if (score >= 4) {
                var myProblem = pw.substr(longestmatchstart, longestmatchstart + longestmatchlength + 1);
                problemText = myProblem.escapeHTML();
                var ALLDIGITS = new RegExp("^[0-9]+$");
                if (myProblem.match(ALLDIGITS)) {
                    publicText = "Avoid numerical patterns";
                    sensitiveText = "Avoid numerical patterns like <b>" + problemText + "</b>";
                }
                else {
                    publicText = "Avoid patterns from the alphabet";
                    sensitiveText = "Avoid patterns from the alphabet like <b>" + problemText + "</b>";
                }
                reasonWhy = "Attackers know to guess sequences following the alphabet, in addition to repeated characters or patterns on your keyboard";
            }
        }
        return {
            count: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText,
            problemText: problemText
        };
    }
    RuleFunctions.alphabeticSequenceCheck = alphabeticSequenceCheck;
    function structurePredictable(pw) {
        /* return value 1 (nth most common) - numStructures (1st most common) if the
        password has one of the numStructures most common character-class structures,
        and 0 else */
        var numStructures = 2124;
        var publicText = "";
        var sensitiveText = "";
        var reasonWhy = "";
        //var problemText = "";
        var score = 0;
        var pw = pw.replace(/[A-Z]/g, "U"); // replace uppercase letters with U (do this first since U is uppercase!)
        var pw = pw.replace(/[a-z]/g, "L"); // replace lowercase letters with L
        var pw = pw.replace(/[0-9]/g, "D"); // replace digits with D
        var pw = pw.replace(/[^A-Za-z0-9]/g, "S"); // replace everything else with S
        var whereInArray = Constants.Constants.commonStructures.indexOf(pw);
        if (whereInArray >= 0) {
            score = numStructures - whereInArray;
            //problemText = "";
            reasonWhy = "One technique attackers use is to try all possible passwords within common structures, or arrangements of character classes (e.g., where lowercase letters and digits are located)";
            publicText = "The way you structure your password is predictable";
            sensitiveText = publicText + " (";
            // convert the structure shorthand to something intelligible
            var theStructure = "";
            var firstone = true; // used to determine whether to precede text with a comma
            var j = 0;
            while (j < pw.length) {
                var k = 0;
                while (((j + k) < pw.length) && (pw.charAt(j) === pw.charAt(j + k))) {
                    k++;
                }
                if (!firstone) {
                    sensitiveText += ", ";
                }
                firstone = false;
                sensitiveText += (k).toString() + " ";
                if (pw.charAt(j) === "L") {
                    sensitiveText += "lowercase letter";
                }
                else if (pw.charAt(j) === "U") {
                    sensitiveText += "uppercase letter";
                }
                else if (pw.charAt(j) === "D") {
                    sensitiveText += "digit";
                }
                else if (pw.charAt(j) === "S") {
                    sensitiveText += "symbol";
                }
                if (k > 1) {
                    sensitiveText += "s";
                }
                j = j + k;
            }
            sensitiveText += ")";
        }
        return {
            score: score,
            reasonWhy: reasonWhy,
            publicText: publicText,
            sensitiveText: sensitiveText
        };
    }
    RuleFunctions.structurePredictable = structurePredictable;
})(RuleFunctions = exports.RuleFunctions || (exports.RuleFunctions = {}));

},{"./PasswordMeter":1,"./constants":4,"./helper":6}],9:[function(require,module,exports){
/* ***************** */
/* STRING EXTENSIONS */
/* ***************** */
String.prototype.replaceAt = function (index, str) {
    return this.substr(0, index) + str + this.substr(index + 1);
};
// Returns an array of all substrings after lowercasing the password.
// Substrings are ordered from longest to shortest (min_length).
String.prototype.listSubstringsNoFilter = function (minLength) {
    var a = new Array();
    var sanitized = this.toLowerCase();
    var theLength = sanitized.length;
    for (var i = theLength; i >= (minLength - 1); i--) {
        for (var j = 0; (i + j) < theLength; j++) {
            var sub = sanitized.substring(j, j + i + 1);
            a.push(sub);
        }
    }
    return a;
};
// Escape HTML in the concrete suggestion to avoid mangling the HTML layout
String.prototype.escapeHTML = function () {
    return this.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
};
// Returns an array of all substrings after removing non-alphabetic characters 
// and lowercasing the password. 
// Substrings are ordered from longest to shortest (min_length).
String.prototype.listSubstrings = function (minLength) {
    var a = new Array();
    var sanitized = this.toLowerCase();
    // Remove non-letters
    var sanitized = sanitized.replace(/[^a-z]/g, "");
    var theLength = sanitized.length;
    for (var i = theLength; i >= (minLength - 1); i--) {
        for (var j = 0; (i + j) < theLength; j++) {
            var sub = sanitized.substring(j, j + i + 1);
            a.push(sub);
        }
    }
    return a;
};
// Returns ASCII frequency array
String.prototype.frequencies = function () {
    var asciiArray = [];
    for (var i = 0; i < this.length; i++) {
        var ascii = this.charCodeAt(i);
        if (asciiArray[ascii] == undefined) {
            asciiArray[ascii] = 0;
        }
        asciiArray[ascii]++;
    }
    return asciiArray;
};
// Return only one instance of each character that appears in a string
String.prototype.removeDuplicateChars = function () {
    return this.split('').filter(function (item, i, ar) {
        return ar.indexOf(item) === i;
    }).join('');
};
// Returns the reverse of any string
String.prototype.reverse = function () {
    var a = '';
    var i = this.length;
    while (i--) {
        a += this[i];
    }
    return a;
};

},{}],10:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var PasswordMeter = require("./PasswordMeter");
var RuleFunctions = require("./rulefunctions");
var UIMisc;
(function (UIMisc_1) {
    var UIMisc = (function () {
        function UIMisc() {
            // Global variable to retain the password when the modal was opened,
            // so that we later know whether or not to show a 'discard' button
            this.pwWhenModalOpened = "";
            // Global variable indicating whether they ever clicked the concerete suggestion.
            // If so, don't show them another fixed password unless they drop 
            // below the 2/3rds threshold.
            this.tookSuggestion = false;
            // Global variable to store what password's rating is currently shown
            this.previouslyRated = "";
            // Previously computed information about password scores and feedback
            // To avoid scoring things multiple times, store mappings in associative arrays
            // -1 means that we already spawned a thread to perform this calculation, so don't duplicate it
            // Mapping of passwords to score based on advanced heuristics
            this.heuristicMapping = {};
            // Mapping of passwords to score based on neural networks
            this.neuralnetMapping = {};
            // Mapping of passwords to public/sensitive feedback
            // potentialTODO that could get expensivex
            // potentialTODO structure this
            this.feedbackMapping = {};
            // Previously computed information about concrete suggestions
            // Mapping of passwords to a potential concrete suggestion. 
            // If the suggestion is scored highly enough, then store it in fixedpwMapping.
            this.recommendedFixes = {};
            // To avoid excess computation, keep track of how many tries we've made
            // trying to generate a strong concerete suggestion. If too many, 
            // give up rather than potentially cause UI lag.
            this.recommendedFixesTries = {};
            // Keep track of the previous candidate we tried for the concrete suggestion.
            // If insufficiently strong, we'll want to modify it
            this.previousCandidate = {};
            // Final mapping of password to (pre-validated) stronger concrete suggestion
            this.fixedpwMapping = {};
            // How the concrete suggestion was modified from the original (for highlights)
            this.deltaHighlighted = {};
            // Globally keep track of whether the password is in compliance with the 
            // composition policy. We use this to decide whether to let them continue.
            // We store this in a global to avoid double-calling the function each time.
            this.inCompliance = false;
            var registry = PasswordMeter.PasswordMeter.instance;
            this.helper = registry.getHelper();
            this.$ = registry.getJquery();
        }
        UIMisc.prototype.onReady = function () {
            // Make the non-modal (feedback box) appear
            this.$(".pop").fadeIn();
            // Reset hide/show checkbox in case they reloaded the page
            // and call the function that shows password/******** based on it
            this.$("#showHidePWNonModal").prop("checked", false);
            this.toggleShowHideNonModal();
            // Rate the password in the box (if any)
            this.spawnRating();
        };
        // This function switches between the password being ***** and shown in non-modal
        UIMisc.prototype.toggleShowHideNonModal = function () {
            if (this.$("#showHidePWNonModal").prop("checked")) {
                this.$("#pwbox").prop("type", "text");
                this.$("#pwboxModal").prop("type", "text");
                // Make non-modal and modal checkboxes match
                this.$("#showHidePWModal").prop("checked", true);
            }
            else {
                this.$("#pwbox").prop("type", "password");
                this.$("#pwboxModal").prop("type", "password");
                // Make non-modal and modal checkboxes match
                this.$("#showHidePWModal").prop("checked", false);
            }
            this.spawnRating();
        };
        // This function switches between the password being ***** and shown in modal
        UIMisc.prototype.toggleShowHideModal = function () {
            if (this.$("#showHidePWModal").prop("checked")) {
                this.$("#pwbox").prop("type", "text");
                this.$("#pwboxModal").prop("type", "text");
                // Make non-modal and modal checkboxes match
                this.$("#showHidePWNonModal").prop("checked", true);
            }
            else {
                this.$("#pwbox").prop("type", "password");
                this.$("#pwboxModal").prop("type", "password");
                // Make non-modal and modal checkboxes match
                this.$("#showHidePWNonModal").prop("checked", false);
            }
            this.spawnRating();
        };
        // Function called when the modal window is opened.
        // Save what the password is at this point and transfer 
        // the password from the main window to the modal
        UIMisc.prototype.storepw = function () {
            var pw = this.$("#pwbox").val();
            this.pwWhenModalOpened = pw;
            this.$("#pwboxModal").val(pw);
        };
        // Show the discard button in the modal only if they edited the password field
        UIMisc.prototype.enableDiscard = function () {
            // If they haven't changed the password since opening the modal
            if (this.$("#pwboxModal").val() === this.pwWhenModalOpened) {
                this.$("#discardButton").hide();
                this.$("#keepButton").html("OK");
            }
            else {
                this.$("#discardButton").show();
                this.$("#keepButton").html("Keep Changes");
            }
        };
        // They chose to keep their modal-modified password,
        // so transfer it to the main window
        UIMisc.prototype.keeppw = function () {
            this.$("#pwbox").val(this.$("#pwboxModal").val());
        };
        // If they click the concrete suggestion in the non-modal, put it in the password field
        UIMisc.prototype.fixPWNonModal = function () {
            // Note for later that they have taken a suggestion
            this.tookSuggestion = true;
            var newpw = this.$("#nonmodalFixedPW").text();
            this.$("#pwbox").val(newpw);
            // Update the rating
            this.spawnRating();
        };
        // If they click the concrete suggestion in the modal, put it in the password field
        UIMisc.prototype.fixPWModal = function () {
            this.tookSuggestion = true;
            var pw = this.$("#modalFixedPW").text();
            this.$("#pwboxModal").val(pw);
            this.spawnRating();
            this.enableDiscard();
        };
        // Set up the modal when they are initially showing it
        UIMisc.prototype.showModal = function () {
            this.storepw();
            this.$("#discardButton").hide();
            this.$("#keepButton").html("OK");
            this.$("#myModal").modal('show');
        };
        // To save computation, only rate the password if it has changed
        UIMisc.prototype.mayberate = function () {
            if (this.$("#pwbox").val() !== this.previouslyRated) {
                this.previouslyRated = this.$("#pwbox").val();
                this.spawnRating();
            }
        };
        // When they try to submit, decide whether to let them continue
        UIMisc.prototype.continueCheck = function (triedToSubmit) {
            var compliantOverall = true;
            // Make sure username is non-empty
            if (triedToSubmit) {
                var username = this.$("#usernamebox").val();
                if (username.length < 1) {
                    this.$("#usernameTooShort").show();
                    compliantOverall = false;
                }
                else {
                    this.$("#usernameTooShort").hide();
                }
            }
            // Check compliance with the password-composition policy
            if (!this.inCompliance) {
                compliantOverall = false;
                // Also hide confirmation error messages
                this.$("#confirmDoesNotMatch").hide();
                // Only turn red when they try to submit
                if (triedToSubmit) {
                    this.$("#feedbackHeaderText").css({
                        "color": "red",
                        "font-weight": "bold"
                    });
                    this.$("#passwordNonCompliant").show();
                }
            }
            else {
                // It is in compliance, so turn everything back to normal
                this.$("#feedbackHeaderText").css({
                    "color": "",
                    "font-weight": ""
                });
                this.$("#passwordNonCompliant").hide();
            }
            // Check that the confirm box matches the password
            if (this.$("#pwbox").val() !== this.$("#confirmbox").val()) {
                compliantOverall = false;
                // Only show the error when they try to submit a compliant pw
                if (triedToSubmit && this.inCompliance) {
                    this.$("#confirmDoesNotMatch").show();
                }
            }
            else {
                this.$("#confirmDoesNotMatch").hide();
            }
            // If meets policy, matches confirm, and they hit submit, let them
            if (triedToSubmit && compliantOverall) {
                alert("this would be submitted");
            }
        };
        // The main function for starting the password-rating process.
        // This function determines whether we've already calculated scores for 
        // a given password using both heuristics and neural networks. 
        // If so, call the function to show results.
        // If not (undefined mappings), change the mappings temporarily to -1 
        // and spawns the ratings. 
        // When those functions return, display will be called via callbacks.
        UIMisc.prototype.spawnRating = function () {
            var pw = "";
            var nni = PasswordMeter.PasswordMeter.instance.getNN();
            var log = PasswordMeter.PasswordMeter.instance.getLog();
            var nn = nni.nn;
            if (this.$("#myModal").data("bs.modal") && this.$("#myModal").data("bs.modal").isShown) {
                pw = this.$("#pwboxModal").val();
            }
            else {
                pw = this.$("#pwbox").val();
            }
            var username = this.$("#usernamebox").val();
            var ratingsComplete = 0;
            if (typeof (this.neuralnetMapping[pw]) === "undefined") {
                // Signal that we are calculating it to avoid duplicate work
                this.neuralnetMapping[pw] = -1;
                // Asynchronously calculate neural network guess number
                log.debug("sending " + pw + " to normal client");
                nn.query_guess_number(pw);
            }
            else if (this.neuralnetMapping[pw] >= 0) {
                ratingsComplete++;
            }
            if (typeof (this.heuristicMapping[pw]) === "undefined") {
                this.queryHeuristicGuessNumber(pw, username, true);
            }
            else if (this.heuristicMapping[pw] >= 0) {
                ratingsComplete++;
            }
            // If we have both ratings, or neural nets doesn't seem to work
            // on this browser, or the password is empty, display the rating.
            if (pw.length === 0 || !nni.heardFromNn() || ratingsComplete === 2) {
                this.displayRating(pw);
            }
        };
        // This function tries to generate a candidate for the conrete suggestion
        // following randomly chosen modification strategies.
        // It requires the current candidate (pw), the current recursion depth (depth) 
        // to avoid causing lag, and the original version of the password (originalPW)
        UIMisc.prototype.generateCandidateFixed = function (pw, depth, originalPW) {
            // We keep a vector that tracks changes we make to the password for 
            // future highlighting purposes.
            var deltas = [];
            // If this is the initial call, initialize that vector
            if (typeof (this.deltaHighlighted[pw]) === "undefined") {
                for (var i = 0; i < pw.length; i++) {
                    deltas[i] = 0;
                }
            }
            else {
                deltas = this.deltaHighlighted[pw];
            }
            // Get the current modification of the password
            var modifiedPW = pw;
            if (typeof (this.previousCandidate[pw]) !== "undefined") {
                // We may have already moved digits or symbols
                modifiedPW = this.previousCandidate[pw];
                deltas = this.deltaHighlighted[modifiedPW];
            }
            // Randomly select one of the strategies in a biased way
            var selection = Math.floor(8 * Math.random());
            // Strategy A: toggle case
            if (selection === 0 || selection === 1) {
                var pwLen = modifiedPW.length;
                var loc = Math.floor(pwLen * Math.random());
                if (modifiedPW.charCodeAt(loc) >= 65 && modifiedPW.charCodeAt(loc) <= 90) {
                    modifiedPW = modifiedPW.replaceAt(loc, String.fromCharCode(modifiedPW.charCodeAt(loc) + 32));
                    deltas[loc] = 1;
                }
                else if (modifiedPW.charCodeAt(loc) >= 97 && modifiedPW.charCodeAt(loc) <= 122) {
                    modifiedPW = modifiedPW.replaceAt(loc, String.fromCharCode(modifiedPW.charCodeAt(loc) - 32));
                    deltas[loc] = 1;
                }
                // Strategy B: substitute character
            }
            else if (selection === 2 || selection === 3) {
                var char1 = 32 + Math.floor(Math.random() * 95);
                var loc1 = Math.floor((modifiedPW.length) * Math.random());
                if (modifiedPW.charCodeAt(loc1) !== char1) {
                    deltas[loc1] = 1;
                }
                modifiedPW = modifiedPW.replaceAt(loc1, String.fromCharCode(char1));
                // Strategy C: insert character
            }
            else if (selection >= 4) {
                var char1 = 32 + Math.floor(Math.random() * 95);
                var loc1 = Math.floor((modifiedPW.length + 1) * Math.random());
                modifiedPW = modifiedPW.slice(0, loc1) + String.fromCharCode(char1) + modifiedPW.slice(loc1);
                deltas = deltas.slice(0, loc1).concat(1, deltas.slice(loc1));
            }
            // Check the modification's compliance with the password-composition policy
            var currentUsername = this.$("#usernamebox").val();
            var verified = RuleFunctions.RuleFunctions.verifyMinimumRequirements(modifiedPW, currentUsername);
            if (verified.compliant) {
                // If it complies with the policy
                this.recommendedFixes[originalPW] = modifiedPW;
                this.deltaHighlighted[modifiedPW] = deltas;
                var log = PasswordMeter.PasswordMeter.instance.getLog();
                log.info("identified " + modifiedPW + " as a potential fix for " + originalPW);
                if (typeof (this.recommendedFixesTries[originalPW]) === "undefined") {
                    this.recommendedFixesTries[originalPW] = 1;
                }
                else {
                    this.recommendedFixesTries[originalPW] = this.recommendedFixesTries[originalPW] + 1;
                }
                this.spawnFixedRating(modifiedPW); // score the candidate in the background
                // If it does not comply, recursively calls itself to try again.
            }
            else {
                depth++;
                if (depth < 8) {
                    this.generateCandidateFixed(pw, depth, originalPW);
                }
            }
            return 1;
        };
        // A modification of the main function for starting the password-rating process 
        // that instead works to score a candidate concrete suggestion we've auto-generated.
        // This function determines whether we've already calculated scores for 
        // a given password using both heuristics and neural networks. 
        // If so, call the function to show results.
        // If not (undefined mappings), change the mappings temporarily to -1 
        // and spawn the ratings. 
        // When those functions return, display will be called via callbacks.
        UIMisc.prototype.spawnFixedRating = function (pw) {
            var nni = PasswordMeter.PasswordMeter.instance.getNN();
            var log = PasswordMeter.PasswordMeter.instance.getLog();
            var nnFixed = nni.nnfixed;
            var username = this.$("#usernamebox").val();
            if (typeof (this.neuralnetMapping[pw]) === "undefined") {
                this.neuralnetMapping[pw] = -1; // signal that we are calculating it to avoid duplicate work
                log.debug("sending " + pw + " to fixed client");
                nnFixed.query_guess_number(pw); // asynchronously calculate neural network guess number
            }
            if (typeof (this.heuristicMapping[pw]) === "undefined") {
                this.queryHeuristicGuessNumber(pw, username, false);
                // To avoid duplicating call when the heuristic function returns
            }
            else if (this.neuralnetMapping[pw] >= 0 && this.heuristicMapping[pw] >= 0) {
                this.synthesizeFixed(pw);
            }
        };
        // Called when we return new guessing evaluations of a concrete suggestion, 
        // this function synthesizes the results and (if the concrete suggestion is 
        // sufficiently strong) updates the array mapping passwords to suggested ones.
        // It can only synthesize results, though, if both heuristics and neural 
        // networks have returned.
        UIMisc.prototype.synthesizeFixed = function (fixedpw) {
            var overallScore = 0;
            var numberOfScores = 0;
            var changedAnyMappings = false;
            if (typeof (this.heuristicMapping[fixedpw]) !== "undefined"
                && this.heuristicMapping[fixedpw] >= 0) {
                numberOfScores++;
                overallScore = this.heuristicMapping[fixedpw];
            }
            if (typeof (this.neuralnetMapping[fixedpw]) !== "undefined"
                && this.neuralnetMapping[fixedpw] >= 0 && isFinite(this.neuralnetMapping[fixedpw])) {
                numberOfScores++;
                if (overallScore === 0
                    || (overallScore > 0 && this.neuralnetMapping[fixedpw] < overallScore)) {
                    overallScore = this.neuralnetMapping[fixedpw];
                }
            }
            log.debug("result for password: " + fixedpw + " heuristic: "
                + this.heuristicMapping[fixedpw] + " neuralnet: ("
                + this.neuralnetMapping[fixedpw] + " scores: " + numberOfScores);
            // When we have a sufficiently strong concrete suggestion, 
            // find all original passwords that include that as a potential fix 
            // and set it as the mapping
            if (numberOfScores === 2 && overallScore >= 67) {
                log.info(fixedpw + " is a plausible fix above the 2/3rds threshold");
                for (var j in this.recommendedFixes) {
                    if (this.recommendedFixes[j] === fixedpw
                        && typeof (this.fixedpwMapping[j]) === "undefined") {
                        // Now check to make sure this improves the original password
                        var originalOverallScore = 0;
                        if (typeof (this.heuristicMapping[j]) !== "undefined"
                            && this.heuristicMapping[j] >= 0) {
                            originalOverallScore = this.heuristicMapping[j];
                        }
                        if (typeof (this.neuralnetMapping[j]) !== "undefined"
                            && this.neuralnetMapping[j] >= 0
                            && isFinite(this.neuralnetMapping[j])) {
                            if (originalOverallScore === 0
                                || (originalOverallScore > 0
                                    && this.neuralnetMapping[j] < originalOverallScore)) {
                                originalOverallScore = this.neuralnetMapping[j];
                            }
                        }
                        if (overallScore > (originalOverallScore + 15)) {
                            this.fixedpwMapping[j] = fixedpw;
                            log.info("mapping " + j + " to " + fixedpw);
                            changedAnyMappings = true;
                        }
                        else {
                            log.info("not mapping " + j + " to " + fixedpw + " because it is not enough of an improvement " + originalOverallScore + " --> " + overallScore);
                        }
                    }
                }
                // Re-rate things and thus display if we have changed any mappings
                if (changedAnyMappings) {
                    this.spawnRating();
                }
                return 1;
            }
            // Try recursively adding more to the password (to a depth), 
            // but only if it's still the current password (avoid extra computation)
            var currentpw = this.$("#pwbox").val();
            // If the modal is open, the current password is actually what's there
            if (this.$("#myModal").data("bs.modal") && this.$("#myModal").data("bs.modal").isShown) {
                currentpw = this.$("#pwboxModal").val();
            }
            if (this.recommendedFixes[currentpw] === fixedpw
                && numberOfScores === 2
                && typeof (this.fixedpwMapping[currentpw]) === "undefined"
                && typeof (this.recommendedFixesTries[currentpw]) !== "undefined"
                && this.recommendedFixesTries[currentpw] < 8) {
                // Try to generate a better concrete suggestion
                log.info("trying again on " + fixedpw + " as current password is " + currentpw);
                this.generateCandidateFixed(fixedpw, 0, currentpw);
            }
            return 1;
        };
        // A function used to avoid showing redundant text feedback
        // generated by different scoring functions.
        // Returns true (redundant with previous feedback) or false (not redundant).
        UIMisc.prototype.redundant = function (problemText, arrayOfProblems) {
            // Lowercase since some rule functions lowercase feedback
            problemText = problemText.toLowerCase();
            for (var i = 0; i < arrayOfProblems.length; i++) {
                arrayOfProblems[i] = arrayOfProblems[i].toLowerCase();
                if (arrayOfProblems[i].length > 0 && problemText.length > 0) {
                    if ((arrayOfProblems[i].indexOf(problemText) >= 0
                        && problemText.length >= 0.7 * arrayOfProblems[i].length)
                        || (problemText.indexOf(arrayOfProblems[i]) >= 0
                            && arrayOfProblems[i].length >= 0.7 * problemText.length)) {
                        return true;
                    }
                }
            }
            return false;
        };
        // This function calculates the advanced heuristics.
        // It requires the password (pw), the username (username), 
        // and a boolean for which:
        //  *true indicates this is the primary password, so potentially change 
        //	the bar when done calculating
        //  *false indicates we are rating a candidate concrete suggestion
        UIMisc.prototype.queryHeuristicGuessNumber = function (pw, username, primaryPassword) {
            // Used to make 10^{15} fill 2/3rds of the bar
            var scalingFactor = 67 / 15;
            // We overwrite the password if they use contextual or blacklisted content
            // and we need the original to make the correct mappings
            var originalPW = pw;
            var publictips = [];
            var sensitivetips = [];
            var reasonWhy = [];
            var problemText = [];
            // Return JSON objects from all of the rule functions
            var contextualObj = RuleFunctions.RuleFunctions.contextual(pw, [username]);
            pw = contextualObj.remaining;
            // If their whole password is contextual, we hit a type error
            if (typeof (pw) === "undefined") {
                pw = "";
            }
            var blacklistObj = RuleFunctions.RuleFunctions.blacklist(pw);
            pw = blacklistObj.remaining;
            // If their whole password is blacklisted, we hit a type error
            if (typeof (pw) === "undefined") {
                pw = "";
            }
            var lenObj = RuleFunctions.RuleFunctions.pwLength(pw);
            var classObj = RuleFunctions.RuleFunctions.characterClasses(pw);
            var duplicatedObj = RuleFunctions.RuleFunctions.duplicatedCharacters(pw);
            var repeatObj = RuleFunctions.RuleFunctions.repeats(pw);
            var patternsObj = RuleFunctions.RuleFunctions.keyboardPatterns(pw);
            var sequenceObj = RuleFunctions.RuleFunctions.repeatedSections(pw);
            var structureObj = RuleFunctions.RuleFunctions.structurePredictable(pw);
            var upperPredictableObj = RuleFunctions.RuleFunctions.uppercasePredictable(pw);
            var digitsPredictableObj = RuleFunctions.RuleFunctions.digitsPredictable(pw);
            var symbolsPredictableObj = RuleFunctions.RuleFunctions.symbolsPredictable(pw);
            var upperObj = RuleFunctions.RuleFunctions.countUC(pw);
            var lowerObj = RuleFunctions.RuleFunctions.countLC(pw);
            var digitObj = RuleFunctions.RuleFunctions.countDIGS(pw);
            var symbolObj = RuleFunctions.RuleFunctions.countSYMS(pw);
            var dateObj = RuleFunctions.RuleFunctions.identifyDates(pw);
            var minimumObj = RuleFunctions.RuleFunctions.verifyMinimumRequirements(pw, username);
            var alphabeticsequenceObj = RuleFunctions.RuleFunctions.alphabeticSequenceCheck(pw);
            var commonsubstringObj = RuleFunctions.RuleFunctions.commonSubstringCheck(pw);
            var dictionaryCheckObj = RuleFunctions.RuleFunctions.combinedDictCheck(pw);
            var substringArrayNoFilter = pw.listSubstringsNoFilter(4);
            var commonpwObj = RuleFunctions.RuleFunctions.commonPwCheck(substringArrayNoFilter);
            // Take the coefficients from our regression
            var coefficients = [1.530, 0.3129, 0.9912, 0.04637, -0.03885, -0.1172, -0.2976, -0.0008581, -0.3008, -0.5566, 0, 0.9108, 0.7369, 0.7578, 0, -0.1213, -0.2402, -0.1364, -0.5534, 1.927, 0.001496, -0.3946];
            var subscores = [1, lenObj.length, classObj.count, duplicatedObj.count,
                repeatObj.count, patternsObj.score, sequenceObj.count, structureObj.score,
                upperPredictableObj.score, digitsPredictableObj.score, symbolsPredictableObj.score,
                upperObj.count, lowerObj.count, digitObj.count, symbolObj.count, dateObj.count,
                alphabeticsequenceObj.count, commonsubstringObj.count, dictionaryCheckObj.length,
                dictionaryCheckObj.dictionaryTokens, dictionaryCheckObj.substitutionCommonness,
                commonpwObj.length];
            // The first value is the intercept
            var overallScore = coefficients[0];
            // Take the remaining coefficients and multiply by the rule function score
            for (var i = 1; i < coefficients.length; i++) {
                overallScore += coefficients[i] * subscores[i];
            }
            overallScore = overallScore * scalingFactor;
            if (overallScore < (pw.length / 2)) {
                overallScore = pw.length / 2;
            }
            else if (overallScore > 100) {
                overallScore = 100;
            }
            // Save non-empty text feedback from the rule functions
            if (contextualObj.publicText.length > 0) {
                publictips.push(contextualObj.publicText);
                sensitivetips.push(contextualObj.sensitiveText);
                reasonWhy.push(contextualObj.reasonWhy);
                problemText.push(contextualObj.problemText);
            }
            if (blacklistObj.publicText.length > 0) {
                publictips.push(blacklistObj.publicText);
                sensitivetips.push(blacklistObj.sensitiveText);
                reasonWhy.push(blacklistObj.reasonWhy);
                problemText.push(blacklistObj.problemText);
            }
            if (dictionaryCheckObj.publicText.length > 0
                && !this.redundant(dictionaryCheckObj.problemText, problemText)) {
                publictips.push(dictionaryCheckObj.publicText);
                sensitivetips.push(dictionaryCheckObj.sensitiveText);
                reasonWhy.push(dictionaryCheckObj.reasonWhy);
                problemText.push(dictionaryCheckObj.problemText);
            }
            if (patternsObj.publicText.length > 0) {
                publictips.push(patternsObj.publicText);
                sensitivetips.push(patternsObj.sensitiveText);
                reasonWhy.push(patternsObj.reasonWhy);
                problemText.push(patternsObj.problemText);
            }
            if (repeatObj.publicText.length > 0) {
                publictips.push(repeatObj.publicText);
                sensitivetips.push(repeatObj.sensitiveText);
                reasonWhy.push(repeatObj.reasonWhy);
                problemText.push(repeatObj.problemText);
            }
            if (dateObj.publicText.length > 0) {
                publictips.push(dateObj.publicText);
                sensitivetips.push(dateObj.sensitiveText);
                reasonWhy.push(dateObj.reasonWhy);
                problemText.push(dateObj.problemText);
            }
            if (sequenceObj.publicText.length > 0) {
                publictips.push(sequenceObj.publicText);
                sensitivetips.push(sequenceObj.sensitiveText);
                reasonWhy.push(sequenceObj.reasonWhy);
                problemText.push(sequenceObj.problemText);
            }
            if (alphabeticsequenceObj.publicText.length > 0) {
                publictips.push(alphabeticsequenceObj.publicText);
                sensitivetips.push(alphabeticsequenceObj.sensitiveText);
                reasonWhy.push(alphabeticsequenceObj.reasonWhy);
                problemText.push(alphabeticsequenceObj.problemText);
            }
            if (commonpwObj.publicText.length > 0 && !this.redundant(commonpwObj.problemText, problemText)) {
                publictips.push(commonpwObj.publicText);
                sensitivetips.push(commonpwObj.sensitiveText);
                reasonWhy.push(commonpwObj.reasonWhy);
                problemText.push(commonpwObj.problemText);
            }
            if (upperPredictableObj.publicText.length > 0) {
                publictips.push(upperPredictableObj.publicText);
                sensitivetips.push(upperPredictableObj.sensitiveText);
                reasonWhy.push(upperPredictableObj.reasonWhy);
                problemText.push(upperPredictableObj.problemText);
            }
            if (digitsPredictableObj.publicText.length > 0) {
                publictips.push(digitsPredictableObj.publicText);
                sensitivetips.push(digitsPredictableObj.sensitiveText);
                reasonWhy.push(digitsPredictableObj.reasonWhy);
                problemText.push(digitsPredictableObj.problemText);
            }
            if (symbolsPredictableObj.publicText.length > 0) {
                publictips.push(symbolsPredictableObj.publicText);
                sensitivetips.push(symbolsPredictableObj.sensitiveText);
                reasonWhy.push(symbolsPredictableObj.reasonWhy);
                problemText.push(symbolsPredictableObj.problemText);
            }
            if (duplicatedObj.publicText.length > 0) {
                publictips.push(duplicatedObj.publicText);
                sensitivetips.push(duplicatedObj.sensitiveText);
                reasonWhy.push(duplicatedObj.reasonWhy);
                problemText.push(duplicatedObj.problemText);
            }
            if (lenObj.publicText.length > 0) {
                publictips.push(lenObj.publicText);
                sensitivetips.push(lenObj.sensitiveText);
                reasonWhy.push(lenObj.reasonWhy);
                //problemText.push(lenObj.problemText);
            }
            if (symbolObj.publicText.length > 0) {
                publictips.push(symbolObj.publicText);
                sensitivetips.push(symbolObj.sensitiveText);
                reasonWhy.push(symbolObj.reasonWhy);
                //problemText.push(symbolObj.problemText);
            }
            if (upperObj.publicText.length > 0) {
                publictips.push(upperObj.publicText);
                sensitivetips.push(upperObj.sensitiveText);
                reasonWhy.push(upperObj.reasonWhy);
                //problemText.push(upperObj.problemText);
            }
            if (digitObj.publicText.length > 0) {
                publictips.push(digitObj.publicText);
                sensitivetips.push(digitObj.sensitiveText);
                reasonWhy.push(digitObj.reasonWhy);
                //problemText.push(digitObj.problemText);
            }
            if (lowerObj.publicText.length > 0) {
                publictips.push(lowerObj.publicText);
                sensitivetips.push(lowerObj.sensitiveText);
                reasonWhy.push(lowerObj.reasonWhy);
                //problemText.push(lowerObj.problemText);
            }
            if (commonsubstringObj.publicText.length > 0 && !this.redundant(commonsubstringObj.problemText, problemText)) {
                publictips.push(commonsubstringObj.publicText);
                sensitivetips.push(commonsubstringObj.sensitiveText);
                reasonWhy.push(commonsubstringObj.reasonWhy);
                //problemText.push(commonsubstringObj.problemText);
            }
            if (structureObj.publicText.length > 0) {
                publictips.push(structureObj.publicText);
                sensitivetips.push(structureObj.sensitiveText);
                reasonWhy.push(structureObj.reasonWhy);
                //problemText.push(structureObj.problemText);
            }
            // Save the mapping of password to score
            this.heuristicMapping[originalPW] = overallScore;
            // Save the mapping of password to feedback
            this.feedbackMapping[originalPW] = JSON.stringify({
                publictips1: publictips[0],
                publictips2: publictips[1],
                publictips3: publictips[2],
                sensitivetips1: sensitivetips[0],
                sensitivetips2: sensitivetips[1],
                sensitivetips3: sensitivetips[2],
                reasonWhy1: reasonWhy[0],
                reasonWhy2: reasonWhy[1],
                reasonWhy3: reasonWhy[2]
            });
            // Display the rating if it's the currently shown (primary) password
            if (primaryPassword) {
                // Possible duplicate call of displayRating since calling in spawnRating.
                this.displayRating(originalPW);
                // also cache modifications to a fixed password
                if (digitsPredictableObj.fixedPw.length > 0) {
                    this.previousCandidate[originalPW] = digitsPredictableObj.fixedPw;
                    this.deltaHighlighted[digitsPredictableObj.fixedPw] = digitsPredictableObj.deltas;
                }
                else if (symbolsPredictableObj.fixedPw.length > 0) {
                    this.previousCandidate[originalPW] = symbolsPredictableObj.fixedPw;
                    this.deltaHighlighted[symbolsPredictableObj.fixedPw] = symbolsPredictableObj.deltas;
                }
                // Otherwise, we're just scoring a concrete suggestion
            }
            else {
                this.synthesizeFixed(originalPW);
            }
        };
        // set the mapping from the neural network
        UIMisc.prototype.setNeuralnetMapping = function (pw, value) {
            this.neuralnetMapping[pw] = value;
        };
        // Update all aspects of the UI (bar and text feedback) to reflect password. 
        // Note that the password score and feedback was generated + cached in other functions.
        UIMisc.prototype.displayRating = function (pw) {
            var overallScore = 0;
            var numberOfScores = 0;
            if (pw.length > 0) {
                if (typeof (this.heuristicMapping[pw]) !== "undefined"
                    && this.heuristicMapping[pw] >= 0) {
                    overallScore = this.heuristicMapping[pw];
                    numberOfScores++;
                }
                if (typeof (this.neuralnetMapping[pw]) !== "undefined"
                    && this.neuralnetMapping[pw] >= 0 && isFinite(this.neuralnetMapping[pw])) {
                    numberOfScores++;
                    if (overallScore == 0 || (overallScore > 0
                        && this.neuralnetMapping[pw] < overallScore)) {
                        overallScore = this.neuralnetMapping[pw];
                    }
                }
            }
            if (overallScore < pw.length / 2) {
                overallScore = pw.length / 2; // make people see at least some progess is happening
            }
            log.info(pw + " overall from heuristic (" + this.heuristicMapping[pw] + ") and neural nets (" + this.neuralnetMapping[pw] + ")");
            // Avoid errors in case the feedback mapping was somehow screwed up
            if (typeof (this.feedbackMapping[pw]) === "undefined") {
                this.feedbackMapping[pw] = JSON.stringify({
                    publictips1: "",
                    publictips2: "",
                    publictips3: "",
                    sensitivetips1: "",
                    sensitivetips2: "",
                    sensitivetips3: "",
                    reasonWhy1: "",
                    reasonWhy2: "",
                    reasonWhy3: ""
                });
            }
            var feedback = JSON.parse(this.feedbackMapping[pw]);
            var config = PasswordMeter.PasswordMeter.instance.getConfig();
            var currentUsername = this.$("#usernamebox").val();
            var nni = PasswordMeter.PasswordMeter.instance.getNN();
            var minReqObj = RuleFunctions.RuleFunctions.verifyMinimumRequirements(pw, currentUsername);
            // If password complies with password policy, show feedback
            if (minReqObj.compliant) {
                this.inCompliance = true;
                if (pw.length === 0 || !nni.heardFromNn() || numberOfScores === 2) {
                    this.displayBar(overallScore, true);
                }
                this.$(".detailedFeedback").show();
                // For the non-modal display
                // Show the button for the password-specific modal
                this.$(".portalToGenericAdviceModal").hide();
                // Show (Why?) buttons that bring people to the modal
                this.$(".explainWhy").show();
                // Show only 3 tips for improving the password
                this.$("#nonmodalRow1").show();
                this.$("#nonmodalRow2").show();
                this.$("#nonmodalRow3").show();
                this.$("#nonmodalRow4").hide();
                this.$("#nonmodalRow5").hide();
                this.$("#nonmodalRow6").hide();
                this.$("#nonmodalRow7").hide();
                this.$("#nonmodalRow8").hide();
                // Also show the confirm password box
                this.$("#confirmpw").show();
                // For the modal display
                // First hide all and then show the relevant ones
                this.$(".modalRow").hide();
                this.$("#modalRow1").show();
                this.$("#modalRow1a").show();
                this.$("#modalRow2").show();
                this.$("#modalRow2a").show();
                this.$("#modalRow3").show();
                this.$("#modalRow3a").show();
                // If we have < 3 pieces of feedback, hide relevant rows
                if (typeof (feedback.publictips3) === "undefined") {
                    this.$("#nonmodalRow3").hide();
                    this.$("#modalRow3").hide();
                    this.$("#modalRow3a").hide();
                }
                if (typeof (feedback.publictips2) === "undefined") {
                    this.$("#nonmodalRow2").hide();
                    this.$("#modalRow2").hide();
                    this.$("#modalRow2a").hide();
                }
                if (typeof (feedback.publictips1) === "undefined") {
                    this.$("#nonmodalRow1").hide();
                    this.$("#modalRow1").hide();
                    this.$("#modalRow1a").hide();
                }
                // Display text heading reflecting the score
                if (overallScore <= 33) {
                    var feedbackWeak = "Your password is very easy to guess.";
                    this.$("#feedbackHeaderText").html(feedbackWeak);
                    this.$("#feedbackHeaderTextModal").html(feedbackWeak);
                }
                else if (overallScore <= 66) {
                    var feedbackLowMedium = "Your password could be better.";
                    this.$("#feedbackHeaderText").html(feedbackLowMedium);
                    this.$("#feedbackHeaderTextModal").html(feedbackLowMedium);
                }
                else if (overallScore < 100) {
                    var feedbackHighMedium = "Your password is pretty good.";
                    if (config.remindAgainstReuse) {
                        feedbackHighMedium += " Use it only for this account. <span class='explainWhy explainWhyColoring' onclick=\"$('#myModalGeneric').modal('show');$('#okGeneric').prop('disabled', false);\" data-target='#myModalGeneric' data-target='#myModal'>(Why?)</span>";
                    }
                    feedbackHighMedium += "<br><p style='line-height:0.25em;'>&nbsp;</p>To make it even better:";
                    this.$("#feedbackHeaderText").html(feedbackHighMedium);
                    this.$("#feedbackHeaderTextModal").html(feedbackHighMedium);
                }
                else {
                    var feedbackStrong = "Your password appears strong.";
                    if (config.remindAgainstReuse) {
                        feedbackStrong += " Make sure you use it only for this account. <span class='explainWhy explainWhyColoring' onclick=\"$('#myModalGeneric').modal('show');$('#okGeneric').prop('disabled', false);\" data-target='#myModalGeneric' data-target='#myModal'>(Why?)</span>";
                    }
                    this.$("#feedbackHeaderText").html(feedbackStrong);
                    this.$("#feedbackHeaderTextModal").html(feedbackStrong);
                }
                // Show colored boxes taken away when non-compliant with the password policy
                this.$(".nonmodalColorCell").show();
                this.$(".modalColorCell").show();
                this.$(".modalColorCellSpacer").show();
                // Populate table with appropriate feedback
                this.$(".recommended").show();
                // If they are showing their password, use sensitive feedback
                if (this.$("#showHidePWNonModal").prop("checked") === true) {
                    this.$(".fixedPWavailablePortal").hide();
                    this.$(".concreteSuggestionDiv").show();
                    // Non-modal
                    this.$("#tipText1").html(feedback.sensitivetips1);
                    this.$("#tipText2").html(feedback.sensitivetips2);
                    this.$("#tipText3").html(feedback.sensitivetips3);
                    // Modal
                    this.$("#suggestion1").html(feedback.sensitivetips1);
                    this.$("#suggestion2").html(feedback.sensitivetips2);
                    this.$("#suggestion3").html(feedback.sensitivetips3);
                    this.$("#sensText1").html(feedback.reasonWhy1);
                    this.$("#sensText2").html(feedback.reasonWhy2);
                    this.$("#sensText3").html(feedback.reasonWhy3);
                }
                else {
                    this.$(".fixedPWavailablePortal").show();
                    this.$(".concreteSuggestionDiv").hide();
                    // Non-modal
                    this.$("#tipText1").html(feedback.publictips1);
                    this.$("#tipText2").html(feedback.publictips2);
                    this.$("#tipText3").html(feedback.publictips3);
                    // Modal
                    this.$("#suggestion1").html(feedback.publictips1);
                    this.$("#suggestion2").html(feedback.publictips2);
                    this.$("#suggestion3").html(feedback.publictips3);
                    this.$("#sensText1").html(feedback.reasonWhy1);
                    this.$("#sensText2").html(feedback.reasonWhy2);
                    this.$("#sensText3").html(feedback.reasonWhy3);
                }
                // Recommend a concrete suggestion if we have one
                if (typeof (this.fixedpwMapping[pw]) !== "undefined") {
                    // Change colors to highlight what was modified
                    var coloredFixedPW = "";
                    var whereToColor = this.deltaHighlighted[this.fixedpwMapping[pw]];
                    var proposedPassword = this.fixedpwMapping[pw];
                    for (var j = 0; j < proposedPassword.length; j++) {
                        if (whereToColor[j] === 1) {
                            coloredFixedPW += "<span class='deltaHighlights'>" + proposedPassword[j].escapeHTML() + "</span>";
                        }
                        else {
                            coloredFixedPW += proposedPassword[j].escapeHTML();
                        }
                    }
                    this.$(".fixedPW").html(coloredFixedPW);
                    // If we don't yet have a concrete suggestion
                }
                else {
                    this.$(".recommended").hide();
                }
                // Hide the feedback if the score is high enough
                if (overallScore <= 66) {
                    this.$("#nonmodalFeedbackTable").show();
                    this.$("#modalFeedbackTable").show();
                    this.$(".portalToGenericAdviceModal").show();
                }
                else if (overallScore < 100) {
                    this.$("#nonmodalFeedbackTable").show();
                    this.$("#modalFeedbackTable").show();
                    this.$(".portalToGenericAdviceModal").show();
                    // If they already took a concrete suggestion, don't show another
                    if (this.tookSuggestion) {
                        this.$(".recommended").hide();
                        this.$(".portalToGenericAdviceModal").hide();
                    }
                }
                else {
                    this.$("#nonmodalFeedbackTable").hide();
                    this.$("#modalFeedbackTable").hide();
                    this.$(".recommended").hide();
                    // Don't show any modal buttons since score is high
                    this.$(".portalToGenericAdviceModal").hide();
                }
                // However, if the password is not yet compliant with the policy
            }
            else {
                this.inCompliance = false;
                var nni = PasswordMeter.PasswordMeter.instance.getNN();
                if (pw.length === 0 || !nni.heardFromNn() || numberOfScores === 2) {
                    this.displayBar(overallScore, false);
                }
                // Don't let them confirm a non-compliant password
                this.$("#confirmpw").hide();
                this.$(".detailedFeedback").hide();
                // Show the button for the generic modal window
                this.$(".portalToGenericAdviceModal").show();
                // Hide (Why?) buttons that bring people to the specific-advice modal
                this.$(".explainWhy").hide();
                // Explain what doesn't comply
                var requirementsHeader = "";
                var config = PasswordMeter.PasswordMeter.instance.getConfig();
                if (config.remindAgainstReuse) {
                    requirementsHeader = "<span style='color:#555555;'>Don't reuse a password from another account!</span> <span class='explainWhy explainWhyColoring' onclick=\"$('#myModalGeneric').modal('show');$('#okGeneric').prop('disabled', false);\" data-target='#myModalGeneric' data-target='#myModal'>(Why?)</span><br><p style='line-height:0.25em;'>&nbsp;</p>";
                }
                var nonCompliantAdmonition = "Your password <span style='text-decoration: underline;'>must</span>:";
                this.$("#feedbackHeaderText").html(requirementsHeader + nonCompliantAdmonition);
                this.$("#feedbackHeaderTextModal").html(requirementsHeader + nonCompliantAdmonition);
                this.$("#nonmodalFeedbackTable").show();
                this.$(".recommended").hide();
                // Give text feedback about how they fail to comply with policy
                var policyGripes = [];
                var detail = minReqObj.detail;
                for (var metric in detail.compliance) {
                    if (!detail.compliance[metric]) {
                        policyGripes.push(detail.explanation[metric]);
                    }
                }
                // Hide the color cells
                this.$(".nonmodalColorCell").hide();
                this.$(".modalColorCell").hide();
                this.$(".modalColorCellSpacer").hide();
                // Hide all of the rows, and then re-show them as necessary below
                this.$(".nonmodalRow").hide();
                this.$(".modalRow").hide();
                for (var i = 0; i < policyGripes.length; i++) {
                    var nmRow = this.$("#nonmodalRow" + (i + 1));
                    var tipText = this.$("#tipText" + (i + 1));
                    var mRow = this.$("#modalRow" + (i + 1));
                    var suggestion = this.$("#suggestion" + (i + 1));
                    var gripe = policyGripes[i];
                    nmRow.show();
                    tipText.html(gripe);
                    mRow.show();
                    suggestion.html(gripe);
                }
            }
            // Start trying to generate a concrete suggestion
            var nni = PasswordMeter.PasswordMeter.instance.getNN();
            if ((pw.length === 0 || !nni.heardFromNn() || numberOfScores === 2)
                && minReqObj.compliant && typeof (this.fixedpwMapping[pw]) === "undefined"
                && overallScore < 100) {
                this.generateCandidateFixed(pw, 0, pw);
            }
        };
        // This function displays the colored bar. It requires the password's score 
        // (expected range 0-100) and a boolean metRequirements indicating yes (true)
        // to display the bar in color or no (false) to display the bar in grayscale 
        // until the requirements have been met.
        UIMisc.prototype.displayBar = function (score, metRequirements) {
            // Adjust score if outside the range
            if (score < 0) {
                score = 0;
            }
            if (score > 100) {
                score = 100;
            }
            // determine bar color
            var scoreProportion = score / 100;
            var barcolor = "rgb(160,160,160)";
            // Initially go from RGB 255,0,0 towards 255,140,0
            if (metRequirements && scoreProportion < 0.45) {
                barcolor = "rgb(" + Math.round(255) + ","
                    + Math.round(scoreProportion / 0.45 * 140) + ",0)";
                // Then go from RGB 255,140,0 towards 255,215,0
            }
            else if (metRequirements && scoreProportion >= 0.45 && scoreProportion < 0.65) {
                barcolor = "rgb(" + Math.round(255) + ","
                    + Math.round((scoreProportion - 0.45) / 0.20 * 75 + 140) + ",0)";
                // Then go from 255,215,0 towards 50,205,50
            }
            else if (metRequirements) {
                barcolor = "rgb(" + Math.round(255 - (scoreProportion - 0.65) / 0.35 * 205)
                    + "," + Math.round(215 - (scoreProportion - 0.65) / 0.035) + ",0)";
            }
            // Display bar in main window
            this.$("#cups-passwordmeter-span").css("width", Math.round(298 * score / 100).toString() + "px");
            this.$("#cups-passwordmeter-span").css("background-color", barcolor);
            // display bar in modal
            this.$("#cups-passwordmeter-span-modal").css("width", Math.round(298 * score / 100).toString() + "px");
            this.$("#cups-passwordmeter-span-modal").css("background-color", barcolor);
        };
        // css interaction
        // potentialTODO this here?
        UIMisc.prototype.getMaxOfArray = function (numArray) {
            return Math.max.apply(null, numArray);
        };
        UIMisc.prototype.expandHelpBut = function () {
            this.$('#expandHelpDiv').show();
            this.$('#helpButton').hide();
        };
        UIMisc.prototype.modalShowCheck = function () {
            //checks whether they've checked the box to show their password
            if (this.$("#pwbox").prop("type") == "text") {
                this.$('#myModal').modal('show');
                this.storepw();
                // potentialTODO what is rate? mayberate? commenting.
                //this.rateModal();
            }
            else if (this.$('#expandHelpDiv').is(':visible')) {
                this.$('#myModal').modal('show');
                this.storepw();
                // potentialTODO what is rate? mayberate? commenting.
                //this.rateModal();
            }
            else {
                this.expandHelpBut();
            }
        };
        UIMisc.prototype.closeDiv = function (divName) {
            this.$(divName).hide();
        };
        // potentialTODO where do the fn params come from?
        UIMisc.prototype.deselect = function (e) {
            if (this.$.fn.slideFadeToggle == undefined) {
                this.$.fn.slideFadeToggle = function (easing, callback) {
                    return this.animate({
                        opacity: 'toggle',
                        height: 'toggle'
                    }, 'fast', easing, callback);
                };
            }
            // potentialTODO force cast for our defined function
            this.$('.pop').slideFadeToggle(function () {
                e.removeClass('selected');
            });
        };
        return UIMisc;
    }());
    UIMisc_1.UIMisc = UIMisc;
    (function () {
        var registry = PasswordMeter.PasswordMeter.instance;
        var $ = registry.getJquery();
        var instance = new UIMisc();
        registry.setUI(instance);
        $(document).ready(function () {
            $("#showpassword").prop('checked', false);
            $("#showpassword").click(function () {
                document.getElementById("hide-show-label").textContent = "Hide Password";
                $("#cbbutton").css('background-color', '#f5f5f5');
                if ($("#pwbox").prop("type") == "password") {
                    $("#pwbox").prop("type", "text");
                }
                else {
                    $("#pwbox").prop("type", "password");
                    document.getElementById("hide-show-label").textContent = "Show Password";
                    $("#cbbutton").css('background-color', '#f5f5f5');
                }
                // potentialTODO what is rate? mayberate? commenting.
                //rate();
            });
        });
        $(document).ready(function () {
            var pw = $("#pwboxModal");
            $("#tip1, #sensText1").mouseover(function () {
                pw.addClass("problemColor");
            });
            $("#tip2, #sensText2").mouseover(function () {
                pw.addClass("problemColor");
            });
            $("#tip3, #sensText3").mouseover(function () {
                pw.addClass("problemColor");
            });
        });
        $(document).ready(function () {
            instance.onReady();
        });
    }());
})(UIMisc = exports.UIMisc || (exports.UIMisc = {}));

},{"./PasswordMeter":1,"./rulefunctions":8}]},{},[2,3,4,5,6,7,1,8,9,10]);
